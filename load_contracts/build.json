{
    "backstops": {
        "address": "0x708fdfe18bf28afe861a69e95419d183ace003eb", 
        "code": [
            "inset('refund.se')", 
            "", 
            "# Keeps track of data for round two backstop [where everyone reports on something] using event as the index", 
            "    # final is whether an event is final", 
            "    # bondReturned is whether the bond principle has been returned", 
            "    # bondPaid is how much on top of the bond principle has been paid to the bond poster", 
            "    # refund is subsidy to pay for round 2 event resolution function call", 
            "    # bondPoster is the account which posted the bond", 
            "    # original ethicality, outcome, and voteperiod specify the first round of consensus values for ethicality, outcome, and voteperiod, respectively", 
            "    # roundTwo states whether an event is a round two event", 
            "data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster, bondReturned, bondPaid, refund)", 
            "", 
            "# Keeps track of data for the forking backstop [wherein the network is forked into two sets of rep] using event as the index", 
            "    # moved is used for stating whether an event has been moved to the winning fork", 
            "    # bondPaid is how much on top of the bond principle has been paid to the bond poster", 
            "    # bondAmount is the amount of the bond", 
            "    # bondPoster is the account which posted the bond", 
            "    # forkedOverEthicality states whether the event was forked due to controversy of ethicality", 
            "    # originalBranch is the branch the event was originally on", 
            "data forking[](bondPoster, bondAmount, forkedOverEthicality, bondPaid, originalBranch, moved)", 
            "", 
            "# Given a branch and a forkPeriod it states which fork the winner was", 
            "data resolved[][]", 
            "", 
            "def setRoundTwoRefund(event, amt):", 
            "    self.roundTwo[event].refund = amt", 
            "    return(1)", 
            "", 
            "def doRoundTwoRefund(sender, event):", 
            "    send(sender, self.roundTwo[event].refund)", 
            "    return(1)", 
            "", 
            "def setForkBondPoster(event, poster):", 
            "    self.forking[event].bondPoster = poster", 
            "    return(1)", 
            "", 
            "def getForkBondPoster(event):", 
            "    return(self.forking[event].bondPoster)", 
            "", 
            "def setForkedOverEthicality(event):", 
            "    self.forking[event].forkedOverEthicality = 1", 
            "    return(1)", 
            "", 
            "def getForkedOverEthicality(event):", 
            "    return(self.forking[event].forkedOverEthicality)", 
            "", 
            "def adjForkBondPaid(event, amount):", 
            "    self.forking[event].bondPaid += amount", 
            "    return(1)", 
            "", 
            "def getForkBondPaid(event):", 
            "    return(self.forking[event].bondPaid)", 
            "", 
            "# sets bond amount for a fork bond", 
            "def setBondAmount(event, amount):", 
            "    self.forking[event].bondAmount = amount", 
            "    return(1)", 
            "", 
            "# gets bond amount for a fork bond", 
            "def getBondAmount(event):", 
            "    return(self.forking[event].bondAmount)", 
            "", 
            "def setOriginalBranch(event, branch):", 
            "    self.forking[event].originalBranch = branch", 
            "    return(1)", 
            "", 
            "def getOriginalBranch(event):", 
            "    return(self.forking[event].originalBranch)", 
            "", 
            "def setMoved(event):", 
            "    self.forking[event].moved = 1", 
            "    return(1)", 
            "", 
            "def getMoved(event):", 
            "    return(self.forking[event].moved)", 
            "", 
            "def setResolved(branch, forkPeriod, winner):", 
            "    self.resolved[branch][forkPeriod] = winner", 
            "    return(1)", 
            "", 
            "def getResolved(branch, forkPeriod):", 
            "    return(self.resolved[branch][forkPeriod])", 
            "", 
            "# gets how much of round 2 bond has been paid back", 
            "def getBondPaid(event):", 
            "    return(self.roundTwo[event].bondPaid)", 
            "", 
            "# increases how much of round 2 bond has been paid back", 
            "def increaseBondPaid(event, amount):", 
            "    self.roundTwo[event].bondPaid += amount", 
            "    return(1)", 
            "", 
            "# whether a round 2 bond's principle has been returned", 
            "def getBondReturned(event):", 
            "    return(self.roundTwo[event].bondReturned)", 
            "", 
            "def setBondReturned(event):", 
            "    self.roundTwo[event].bondReturned = 1", 
            "    return(1)", 
            "", 
            "def getRoundTwo(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].roundTwo)", 
            "", 
            "def setRoundTwo(event, roundTwo):", 
            "    self.roundTwo[event].roundTwo = roundTwo", 
            "    return(1)", 
            "", 
            "def getBondPoster(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].bondPoster)", 
            "", 
            "def setBondPoster(event, bondPoster):", 
            "    self.roundTwo[event].bondPoster = bondPoster", 
            "    return(1)", 
            "", 
            "# whether a round 2 event is final", 
            "def getFinal(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].final)", 
            "", 
            "def setFinal(event):", 
            "    self.roundTwo[event].final = 1", 
            "    return(1)", 
            "", 
            "def getOriginalOutcome(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].originalOutcome)", 
            "", 
            "def setOriginalOutcome(event, originalOutcome):", 
            "    self.roundTwo[event].originalOutcome = originalOutcome", 
            "    return(1)", 
            "", 
            "def getOriginalEthicality(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].originalEthicality)", 
            "", 
            "def setOriginalEthicality(event, ethicality):", 
            "    self.roundTwo[event].originalEthicality = ethicality", 
            "    return(1)", 
            "", 
            "def getOriginalVotePeriod(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].originalVotePeriod)", 
            "", 
            "def setOriginalVotePeriod(event, period):", 
            "    self.roundTwo[event].originalVotePeriod = period", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "adjForkBondPaid(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "doRoundTwoRefund(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondAmount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondPaid(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondPoster(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondReturned(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getFinal(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkBondPaid(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkBondPoster(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkedOverEthicality(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMoved(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalEthicality(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkPeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "getResolved(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRoundTwo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "increaseBondPaid(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "setBondAmount(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bondPoster", 
                        "type": "int256"
                    }
                ], 
                "name": "setBondPoster(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setBondReturned(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setFinal(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "poster", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkBondPoster(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkedOverEthicality(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setMoved(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethicality", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalEthicality(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "originalOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalVotePeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winner", 
                        "type": "int256"
                    }
                ], 
                "name": "setResolved(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "roundTwo", 
                        "type": "int256"
                    }
                ], 
                "name": "setRoundTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amt", 
                        "type": "int256"
                    }
                ], 
                "name": "setRoundTwoRefund(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "branches": {
        "address": "0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "inset('refund.se')", 
            "", 
            "# Branches keeps track of data associated with branches in augur", 
            "# Branches' index is the hash of the branch (aka branchID)", 
            "# currentVotePeriod is the current index in eventsExpDates and tells us which bucket of events are up to be", 
            "# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)", 
            "# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)", 
            "# currentExpPeriod - 1 is what's up for reporting at any given time", 
            "# periodLength is the length in seconds of the branch's reporting period", 
            "# parentPeriod is the period the parent was in when the branch was created [useful for claiming rep after a fork]", 
            "# baseReporters the number of reporters which report on a market at a minimum", 
            "# forkPeriod is the period a branch was last forked over", 
            "# eventForkedOver is the event a branch was last forked over", 
            "# parent is the parent branch of the given branch", 
            "# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:", 
            "    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap", 
            "    #Say ev/ebit or valuation is 15, so:", 
            "    #45 * fee * volume per period = rep market cap", 
            "    #Want:", 
            "        #Rep market cap >> outstanding shares value at all times", 
            "# min can be no lower than ~0.0000001 or so otherwise can run into underflow isues", 
            "data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)", 
            "", 
            "# first param is the branch, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "# keeps track of a list of all branches", 
            "data branchList[]", 
            "data branchListCount", 
            "", 
            "def init():", 
            "    self.Branches[1010101].currentVotePeriod = (block.timestamp / 172800) - 1", 
            "    self.Branches[1010101].periodLength = 172800 # 1 week", 
            "    # .5%", 
            "    self.Branches[1010101].minTradingFee = 5000000000000000", 
            "    self.branchListCount = 1", 
            "    self.branchList[0] = 1010101", 
            "    # since only have to report on half this targets 3", 
            "    self.Branches[1010101].baseReporters = 2*3", 
            "", 
            "# call once after uploading (externed method not allowed in init)", 
            "def initDefaultBranch():", 
            "    refund()", 
            "    return(CASH.initiateOwner(1010101))", 
            "", 
            "# event a branch was most recently forked over", 
            "def getEventForkedOver(branch):", 
            "    return(self.Branches[branch].eventForkedOver)", 
            "", 
            "def setEventForkedOver(branch, event):", 
            "    self.Branches[branch].eventForkedOver = event", 
            "    return(1)", 
            "", 
            "def getBaseReporters(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].baseReporters)", 
            "", 
            "def setBaseReporters(branch, num):", 
            "    refund()", 
            "    self.Branches[branch].baseReporters = num", 
            "    return(1)", 
            "", 
            "def getOracleOnly(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].oracleOnly)", 
            "", 
            "def getVotePeriod(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].currentVotePeriod)", 
            "", 
            "def getPeriodLength(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].periodLength)", 
            "", 
            "# branch cash balance at start of period", 
            "def setInitialBalance(branch, period, balance):", 
            "    refund()", 
            "    self.Branches[branch].balance[period] = balance", 
            "    return(balance)", 
            "", 
            "def getInitialBalance(branch, period):", 
            "    refund()", 
            "    return(self.Branches[branch].balance[period])", 
            "", 
            "# @return all markets in a branch", 
            "def getMarketsInBranch(branch):", 
            "    refund()", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "", 
            "def getParent(branch):", 
            "    return(self.Branches[branch].parent)", 
            "", 
            "# @return all markets in a branch", 
            "def getSomeMarketsInBranch(branch, initial, last):", 
            "    refund()", 
            "    numMarkets = last - initial", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[initial+i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getNumMarketsBranch(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].numMarkets)", 
            "", 
            "def getMinTradingFee(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].minTradingFee)", 
            "", 
            "# @return all branches", 
            "def getBranches():", 
            "    refund()", 
            "    b = 0", 
            "    numBranches = self.branchListCount", 
            "    branches = array(numBranches)", 
            "    while b < numBranches:", 
            "        branches[b] = self.branchList[b]", 
            "        b += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumBranches():", 
            "    refund()", 
            "    return(self.branchListCount)", 
            "", 
            "def getBranchByNum(branchNumber):", 
            "    refund()", 
            "    return(self.branchList[branchNumber])", 
            "", 
            "def getCreationDate(ID):", 
            "    refund()", 
            "    return(self.Branches[ID].creationDate)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    refund()", 
            "    if(self.Branches[ID].periodLength==0):", 
            "        self.Branches[ID].currentVotePeriod = currentVotePeriod", 
            "        self.Branches[ID].periodLength = periodLength", 
            "        self.Branches[ID].minTradingFee = minTradingFee", 
            "        self.branchList[self.branchListCount] = ID", 
            "        self.branchListCount += 1", 
            "        self.Branches[ID].creationDate = block.timestamp", 
            "        self.Branches[ID].parentPeriod = parentPeriod", 
            "        self.Branches[ID].oracleOnly = oracleOnly", 
            "        self.Branches[ID].parent = parent", 
            "        self.Branches[ID].baseReporters = self.Branches[parent].baseReporters", 
            "        CASH.initiateOwner(ID)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def getParentPeriod(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].parentPeriod)", 
            "", 
            "def incrementPeriod(branch):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    refund()", 
            "    self.Branches[branch].currentVotePeriod += 1", 
            "    return(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addMarketToBranch(branch, market):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    refund()", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    self.Branches[branch].markets[numMarkets] = market", 
            "    self.Branches[branch].numMarkets += 1", 
            "    return(1)", 
            "", 
            "def setForkPeriod(branch):", 
            "    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod", 
            "    return(1)", 
            "", 
            "# gets the period in which a branch was most recently forked", 
            "def getForkPeriod(branch):", 
            "    return(self.Branches[branch].forkPeriod)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarketToBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getBaseReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branchNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchByNum(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "getBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationDate(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventForkedOver(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getInitialBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "getNumBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarketsBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getOracleOnly(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getParent(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getParentPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initial", 
                        "type": "int256"
                    }, 
                    {
                        "name": "last", 
                        "type": "int256"
                    }
                ], 
                "name": "getSomeMarketsInBranch(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "initDefaultBranch()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minTradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parentPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeBranch(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setBaseReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventForkedOver(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialBalance(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "buy&sellShares": {
        "address": "0x031d9d02520cc708ea3c865278508c9cdb92bd51", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getBestAskID:[int256,int256]:int256, getBestBidID:[int256,int256]:int256, getID:[int256]:int256, getSender:[]:int256, getTradeOwner:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], get_trade_block:[int256]:int256, makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]", 
            "TRADES = 0xd70c6e1f3857d23bd96c3e4d2ec346fa7c3931f3", 
            "extern completeSets: [buyCompleteSets:[int256,int256]:int256, sellCompleteSets:[int256,int256]:int256, test_callstack:[]:int256]", 
            "COMPLETESETS = 0x52ccb0490bc81a2ae363fccbb2b367bca546cec7", 
            "inset('refund.se')", 
            "inset('logReturn.se')", 
            "", 
            "event buyAndSellShares_logReturn(returnValue)", 
            "event log_add_tx(market:indexed, sender:indexed, type, price, amount, outcome, tradeid, isShortAsk, timestamp, tradeGroupID)", 
            "event log_cancel(market:indexed, sender:indexed, price, amount, tradeid, outcome, type, cashRefund, timestamp)", 
            "", 
            "# Trade types", 
            "macro BID: 1", 
            "macro ASK: 2", 
            "# Field counts", 
            "macro TRADE_FIELDS: 8", 
            "# Boolean success/failure", 
            "macro SUCCESS: 1", 
            "macro FAILURE: 0", 
            "# Error codes", 
            "macro INSUFFICIENT_BALANCE: 10", 
            "macro TRADE_ALREADY_EXISTS: 21", 
            "macro TRADE_SAME_BLOCK_PROHIBITED: 22", 
            "", 
            "macro fee_percent($market_fee, $price, $cumScale):", 
            "    4 * $market_fee * $price * (ONE-$price*ONE/$cumScale) / ($cumScale*ONE)", 
            "", 
            "macro save_trade($type, $amount, $price, $market, $outcome, $branch, $fee, $sender, $isShortAsk, $tradeGroupID):", 
            "    trade = [$type, $market, $amount, $price, $sender, block.number, $outcome]", 
            "    trade_id = sha3(trade, items=7)", 
            "    cumScale = MARKETS.getCumScale($market)", 
            "", 
            "    # Save trade", 
            "    if !TRADES.getID(trade_id):", 
            "        TRADES.saveTrade(trade_id, $type, $market, $amount, $price, $sender, $outcome)", 
            "        # Update market", 
            "        last_id = MARKETS.getLastTrade($market)", 
            "        MARKETS.addTrade($market, trade_id, last_id)", 
            "        # Update available and trading amounts for asks", 
            "        if $type == ASK:", 
            "            MARKETS.modifyParticipantShares($market, msg.sender, $outcome, -$amount, 0)", 
            "            if($fee):", 
            "                CASH.sendFrom($market, ($amount * $price / ONE * $fee / ONE), $sender)", 
            "        # Send / escrow cash for bids", 
            "        if $type == BID:", 
            "            CASH.sendFrom($market, $amount * $price / ONE, $sender)", 
            "            if($fee):", 
            "                CASH.sendFrom($market, ($amount * $price / ONE * $fee / ONE), $sender)", 
            "    else:", 
            "        logReturn(buyAndSellShares_logReturn, TRADE_ALREADY_EXISTS)", 
            "    log(type=log_add_tx, $market, $sender, $type, $price, $amount, $outcome, trade_id, $isShortAsk, block.timestamp, $tradeGroupID)", 
            "    logReturn(buyAndSellShares_logReturn, trade_id)", 
            "", 
            "def shortAsk(amount, price, market, outcome, minimumTradeSize, tradeGroupID):", 
            "    refund()", 
            "    buyCompleteSetsResult = COMPLETESETS.buyCompleteSets(market, amount, call=delegate)", 
            "    if buyCompleteSetsResult != amount:", 
            "        return(buyCompleteSetsResult)", 
            "    return(self.sell(amount, price, market, outcome, minimumTradeSize, 1, tradeGroupID, call=delegate))", 
            "", 
            "#", 
            "# Cancellation: cancels a trade, if a bid refunds money, if an ask returns shares", 
            "# @returns 1 if success, 0 if failure", 
            "#", 
            "# 200k gas", 
            "def cancel(trade_id):", 
            "    refund()", 
            "    # user can cancel anytime", 
            "    # Get trade", 
            "    trade = array(TRADE_FIELDS)", 
            "    trade = TRADES.get_trade(trade_id, outitems=TRADE_FIELDS)", 
            "    if !trade:", 
            "        logReturn(buyAndSellShares_logReturn, 0)", 
            "    type = trade[1]", 
            "    market = trade[2]", 
            "    amount = trade[3]", 
            "    price = trade[4]", 
            "    owner = trade[5]", 
            "    outcome = trade[7]", 
            "    branch = MARKETS.getBranchID(market)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    fee = fee_percent(trading_fee, price, cumScale) * MARKETS.getMakerFees(market) / ONE", 
            "    # Check the owner", 
            "    if msg.sender == owner:", 
            "        # Clear the trade first", 
            "        remove_trade(trade_id, market)", 
            "        # Issue refunds", 
            "        if type == BID:", 
            "            # cash refund", 
            "            cashRefund = amount * price / ONE * (fee + ONE) / ONE", 
            "            CASH.subtractCash(market, cashRefund)", 
            "            CASH.addCash(msg.sender, cashRefund)", 
            "        elif type == ASK:", 
            "            # shares refund", 
            "            MARKETS.modifyParticipantShares(market, msg.sender, outcome, amount, 1)", 
            "            cashRefund = (amount * price / ONE * fee / ONE)", 
            "            CASH.subtractCash(market, cashRefund)", 
            "            CASH.addCash(msg.sender, cashRefund)", 
            "        # Log cancellation", 
            "        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type, cashRefund, block.timestamp)", 
            "        logReturn(buyAndSellShares_logReturn, SUCCESS)", 
            "    logReturn(buyAndSellShares_logReturn, FAILURE)", 
            "", 
            "macro remove_trade($trade_id, $market):", 
            "    TRADES.remove_trade($trade_id)", 
            "    MARKETS.remove_trade_from_market($market, $trade_id)", 
            "", 
            "#", 
            "# Buy / Sell actions: puts orders on the book", 
            "# Errors:", 
            "    #  0: market doesn't exist", 
            "    # -1: amount/price bad", 
            "    # -2: oracle only branch", 
            "    # -3: trader doesn't exist in market", 
            "    # -4: not enough money or shares", 
            "    # -5: bid price exceeds best ask", 
            "#", 
            "# costs 532k gas", 
            "# smallest trade value is 0.00000001", 
            "def buy(amount, price, market, outcome, minimumTradeSize, tradeGroupID):", 
            "    refund()", 
            "", 
            "    # Check if there are any \"crossed orders\" (i.e., ask orders", 
            "    # at a price less than or equal to the buy price).", 
            "    bestAskID = TRADES.getBestAskID(market, outcome)", 
            "    if bestAskID != 0 and price >= TRADES.get_price(bestAskID) and TRADES.get_amount(bestAskID) >= minimumTradeSize:", 
            "        logReturn(buyAndSellShares_logReturn, -5)", 
            "", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    fee = fee_percent(trading_fee, price, cumScale) * MARKETS.getMakerFees(market) / ONE", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(!MARKETS.getCreationTime(market)):", 
            "        logReturn(buyAndSellShares_logReturn, 0)", 
            "    # price cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues", 
            "    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):", 
            "        logReturn(buyAndSellShares_logReturn, -1)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        logReturn(buyAndSellShares_logReturn, -2)", 
            "    if(CASH.balance(msg.sender) < (amount * price / ONE * (fee + ONE) / ONE)):", 
            "        logReturn(buyAndSellShares_logReturn, -4)", 
            "    save_trade(BID, amount, price, market, outcome, branch, fee, msg.sender, 0, tradeGroupID)", 
            "    logReturn(buyAndSellShares_logReturn, FAILURE)", 
            "", 
            "# costs 532k gas", 
            "# smallest trade value is 0.00000001", 
            "# Errors:", 
            "    #  0: market doesn't exist", 
            "    # -1: amount/price bad", 
            "    # -2: oracle only branch", 
            "    # -3: trader doesn't exist in market", 
            "    # -4: not enough money or shares", 
            "    # -5: best bid exceeds ask price", 
            "def sell(amount, price, market, outcome, minimumTradeSize, isShortAsk, tradeGroupID):", 
            "    refund()", 
            "", 
            "    # Check if there are any \"crossed orders\" (i.e., bid orders", 
            "    # at a price greater than or equal to the sell price).", 
            "    bestBidID = TRADES.getBestBidID(market, outcome)", 
            "    if bestBidID != 0 and price <= TRADES.get_price(bestBidID) and TRADES.get_amount(bestBidID) >= minimumTradeSize:", 
            "        logReturn(buyAndSellShares_logReturn, -5)", 
            "", 
            "    branch = MARKETS.getBranchID(market)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    fee = fee_percent(trading_fee, price, cumScale) * MARKETS.getMakerFees(market) / ONE", 
            "    # price cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues", 
            "    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):", 
            "        logReturn(buyAndSellShares_logReturn, -1)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        logReturn(buyAndSellShares_logReturn, -2)", 
            "    if(MARKETS.getParticipantSharesPurchased(market, msg.sender, outcome) < amount):", 
            "        logReturn(buyAndSellShares_logReturn, -4)", 
            "    # check for enough money for fees", 
            "    if(CASH.balance(msg.sender) < (amount * price / ONE * fee / ONE)):", 
            "        logReturn(buyAndSellShares_logReturn, -4)", 
            "    save_trade(ASK, amount, price, market, outcome, branch, fee, msg.sender, isShortAsk, tradeGroupID)", 
            "    logReturn(buyAndSellShares_logReturn, FAILURE)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minimumTradeSize", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "buy(int256,int256,int256,int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }
                ], 
                "name": "cancel(int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minimumTradeSize", 
                        "type": "int256"
                    }, 
                    {
                        "name": "isShortAsk", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "sell(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minimumTradeSize", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "shortAsk(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": false, 
                        "name": "returnValue", 
                        "type": "int256"
                    }
                ], 
                "name": "buyAndSellShares_logReturn(int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "isShortAsk", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "log_add_tx(int256,int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cashRefund", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "log_cancel(int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern buy&sellShares: [buy:[int256,int256,int256,int256,int256,int256]:_, cancel:[int256]:_, sell:[int256,int256,int256,int256,int256,int256,int256]:_, shortAsk:[int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "cash": {
        "address": "0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "inset('refund.se')", 
            "", 
            "# address -> value map of \"cash [a made up subcurrency/token for testing\"", 
            "data cashcoinBalances[]", 
            "", 
            "# address -> address mapping of a cash address to the address that owns it", 
            "data owners[]", 
            "", 
            "event sentCash(_from:indexed, _to:indexed, _value, timestamp)", 
            "event deposit(sender:indexed, value, timestamp)", 
            "event withdraw(sender:indexed, to:indexed, value, timestamp)", 
            "", 
            "def init():", 
            "    # test initial funds", 
            "    self.cashcoinBalances[msg.sender] = 100000*ONE", 
            "", 
            "# @return: cash balance of address", 
            "def balance(address):", 
            "    refund()", 
            "    return(self.cashcoinBalances[address])", 
            "", 
            "# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...", 
            "# needs to be called when making a market, branch, etc. or a new cash user acc.", 
            "def initiateOwner(account):", 
            "    refund()", 
            "    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):", 
            "        self.owners[account] = msg.sender", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# Send cash to a receiver from msg.sender", 
            "# should send values as fixed point in UI (1 is ONE, 4 is 4*ONE, .5 is ONEHALF, etc.)", 
            "# @return: value sent, 0 if fails", 
            "def send(recver, value):", 
            "    refund()", 
            "    if(self.owners[msg.sender]==0):", 
            "        self.owners[msg.sender] = msg.sender", 
            "    #if(self.owners[recver]==0):", 
            "    #    return(0)", 
            "    sender = msg.sender", 
            "    senderBalance = self.cashcoinBalances[sender]", 
            "    if(senderBalance >= value && value > 0):", 
            "        self.cashcoinBalances[sender] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        log(type=sentCash, msg.sender, recver, value, block.timestamp)", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# Sends cash from a user to a receiver", 
            "# @return value of cash sent; fail is 0", 
            "def sendFrom(recver, value, from):", 
            "    refund()", 
            "    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.", 
            "    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)", 
            "    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):", 
            "        return(0)", 
            "    #if(self.owners[recver]==0):", 
            "    #    return(0)", 
            "    senderBalance = self.cashcoinBalances[from]", 
            "    if(senderBalance >= value && value > 0):", 
            "        self.cashcoinBalances[from] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# make sure only coming from specific contracts", 
            "def subtractCash(ID, amount):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):", 
            "    #    return(0)", 
            "    self.cashcoinBalances[ID] -= amount", 
            "    return(1)", 
            "", 
            "def addCash(ID, amount):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[ID] += amount", 
            "    return(1)", 
            "", 
            "def setCash(address, balance):", 
            "    refund()", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[address] = balance", 
            "    return(1)", 
            "", 
            "def depositEther():", 
            "    self.cashcoinBalances[msg.sender] += msg.value", 
            "    log(type=deposit, msg.sender, msg.value, block.timestamp)", 
            "    return msg.value", 
            "", 
            "def withdrawEther(to, value):", 
            "    if(value < 0):", 
            "        return(-1)", 
            "    if self.cashcoinBalances[msg.sender] >= value:", 
            "        self.cashcoinBalances[msg.sender] -= value", 
            "        send(to, value)", 
            "        log(type=withdraw, msg.sender, to, value, block.timestamp)", 
            "        return 1", 
            "    else:", 
            "        return 0"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balance(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "depositEther()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "initiateOwner(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "send(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }
                ], 
                "name": "sendFrom(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "withdrawEther(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "deposit(int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "_from", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "_to", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "_value", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "sentCash(int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "withdraw(int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]"
    }, 
    "closeMarket": {
        "address": "0xc1c4e2f32e4b84a60b8b7983b6356af4269aab79", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern payout: [oneOutcome:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, twoOutcomes:[int256,int256[],int256,int256]:int256]", 
            "PAYOUT = 0x35152caa07026203a1add680771afb690d872d7d", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern eventResolution: [determineWinningOutcomes:[int256]:int256[], resolveBinary:[int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "RESOLVE = 0x3f3276849a878a176b2f02dd48a483e8182a49e4", 
            "extern refund.se: [getNumTopicsInBranch:[int256]:int256, getTopicPopularity:[int256,int256]:int256, getTopicsInBranch:[int256,int256,int256]:int256[], getTopicsInfo:[int256,int256,int256]:int256[], test_callstack:[]:int256, updateTopicPopularity:[int256,int256,int256]:int256]", 
            "TOPICS = 0x8caf2c0ce7cdc2e81b58f74322cefdef440b3f8d", 
            "inset('refund.se')", 
            "inset('logReturn.se')", 
            "", 
            "event closedMarket(market: indexed, branch: indexed, sender: indexed)", 
            "event closeMarket_logReturn(returnValue)", 
            "", 
            "# first param is the market, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "# If ethicality value <.5 it's 0, otherwise it's ethical", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "# Loop through events in the market, get their outcomes && use those to determine the winning outcomes and resolve a market!", 
            "# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1", 
            "# Error messages otherwise", 
            "    # -1: Market has no cash anyway / already closed", 
            "    # -2: 0 outcome / not reported on yet", 
            "    # -3: not final round 2 event", 
            "    # -4: market isn't in branch", 
            "    # -5: Event forked and not final yet", 
            "    # -6: bonded pushed forward market not ready to be resolved", 
            "    # -7: already resolved", 
            "# if market's events have moved due to a fork branch param passed should be the new fork [todo check to make sure it handles the wrong branch param properly here]", 
            "def closeMarket(branch, market, sender):", 
            "    refund()", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    event = MARKETS.getMarketEvent(market, 0)", 
            "    if(MARKETS.getOneWinningOutcome(market, 0)):", 
            "        logReturn(closeMarket_logReturn, -1)", 
            "    if(EVENTS.getUncaughtOutcome(event)==0):", 
            "        logReturn(closeMarket_logReturn, -2)", 
            "    if(BACKSTOPS.getRoundTwo(event) && !BACKSTOPS.getFinal(event)):", 
            "        logReturn(closeMarket_logReturn, -3)", 
            "    if(MARKETS.getBranchID(market)!=branch):", 
            "        logReturn(closeMarket_logReturn, -4)", 
            "    # checks whether any events not already resolved", 
            "    resolved = 1", 
            "    # what if we forked or round 2 won't it be resolved and thus market never gets resolved todo", 
            "    if(EVENTS.getOutcome(event)==0 && EVENTS.getmode(event)==0):", 
            "        resolved = 0", 
            "    if((period > tradingPeriod) && !resolved):", 
            "        # look at through event in the market, get its outcomes, resolve it && use those to determine the winning outcomes for a given market!", 
            "        votingPeriodEvent = EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch)", 
            "        fxpOutcome = EVENTS.getOutcome(event)", 
            "        resolution = 1", 
            "        forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))", 
            "        currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)", 
            "        if((EVENTS.getForked(event) && !EVENTS.getForkedDone(event)) or (currentPeriod <= (forkPeriod+1))):", 
            "            logReturn(closeMarket_logReturn, -5)", 
            "        if(binary(event) && fxpOutcome==0):", 
            "            resolution = RESOLVE.resolveBinary(event, market, branch, votingPeriodEvent)", 
            "        elif(scalar(event) && EVENTS.getmode(event)==0):", 
            "            resolution = RESOLVE.resolveCategoricalOrScalar(EVENTS.getMinValue(event), EVENTS.getMaxValue(event), event, market, branch, votingPeriodEvent)", 
            "        elif(categorical(event) && EVENTS.getmode(event)==0):", 
            "            resolution = RESOLVE.resolveCategoricalOrScalar(ONE, ONE*EVENTS.getNumOutcomes(event), event, market, branch, votingPeriodEvent)", 
            "        if(resolution==-6):", 
            "            logReturn(closeMarket_logReturn, -6)", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = RESOLVE.determineWinningOutcomes(event, outitems=8)", 
            "        MARKETS.setWinningOutcomes(market, winningOutcomes)", 
            "        # refunds closing cost", 
            "        MARKETS.refundClosing(market, sender)", 
            "        tags = MARKETS.returnTags(market, outitems=3)", 
            "        TOPICS.updateTopicPopularity(branch, tags[0], -1*MARKETS.getVolume(market))", 
            "        log(type=closedMarket, market, branch, sender)", 
            "        logReturn(closeMarket_logReturn, 1)", 
            "    else:", 
            "        logReturn(closeMarket_logReturn, 0)", 
            "", 
            "# Claim trading profits/value per share after a market is resolved", 
            "# @returns 1 if successful", 
            "# Errors:", 
            "    # 0: market not resolved", 
            "    # -1: trader doesn't exist", 
            "    # -8: invalid branch", 
            "def claimProceeds(branch, market):", 
            "    refund()", 
            "    if(MARKETS.getBranchID(market)!=branch):", 
            "        return(-8)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    event = MARKETS.getMarketEvent(market, 0)", 
            "    resolved = 1", 
            "    if(EVENTS.getOutcome(event)==0 && EVENTS.getmode(event)==0):", 
            "        resolved = 0", 
            "    # as long as it's resolved money can be collected", 
            "    if((period > tradingPeriod || reportingDone) && resolved):", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = MARKETS.getWinningOutcomes(market, outitems=8)", 
            "        outcome = 0", 
            "        # market not resolved", 
            "        if(winningOutcomes[0]==0):", 
            "            return(0)", 
            "        if(winningOutcomes[1]==0):", 
            "            ethical = ethic_catch(EVENTS.getEthical(event))", 
            "            # unethical or .5 categorical 1d market is resolved with all outcomes having equal values", 
            "            if(categorical(event) && (EVENTS.getmode(event)==ONEHALF or !ethical)):", 
            "                outcome = PAYOUT.oneOutcome(market, winningOutcomes[0], msg.sender, 1, EVENTS.getNumOutcomes(event))", 
            "            # resolves a regular binary market", 
            "            else:", 
            "                outcome = PAYOUT.oneOutcome(market, winningOutcomes[0], msg.sender, 0, 0)", 
            "        # resolves a scalar market", 
            "        elif(winningOutcomes[1]):", 
            "            outcome = PAYOUT.twoOutcomes(market, winningOutcomes, event, msg.sender)", 
            "        return(outcome)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "claimProceeds(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "closeMarket(int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": false, 
                        "name": "returnValue", 
                        "type": "int256"
                    }
                ], 
                "name": "closeMarket_logReturn(int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "closedMarket(int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern closeMarket: [claimProceeds:[int256,int256]:int256, closeMarket:[int256,int256,int256]:_, test_callstack:[]:int256]"
    }, 
    "collectFees": {
        "address": "0x81a7621e9a286d061b3dea040888a51c96693b1c", 
        "code": [
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "inset('refund.se')", 
            "", 
            "event collectedFees(branch: indexed, sender: indexed, cashFeesCollected, newCashBalance, repGain, newRepBalance, totalReportingRep, notReportingBond, period, timestamp)", 
            "", 
            "# Allows a user to collect both redistributed rep and trading fees earned at the end of a period", 
            "# Errors:", 
            "    # -1: rep redistribution/rewards/penalizations in consensus not done yet", 
            "    # -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]", 
            "        # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission", 
            "# 2 means already claimed", 
            "def collectFees(branch, sender):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual <= periodLength/2):", 
            "        return(-2)", 
            "    if(!CONSENSUS.getRepRedistributionDone(branch, sender)):", 
            "        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary", 
            "        return(-1)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    lastPeriod = votePeriod - 1", 
            "    newRep = EXPEVENTS.getAfterRep(branch, lastPeriod, sender)", 
            "    if(!CONSENSUS.getFeesCollected(branch, sender, lastPeriod)):", 
            "        denominator = CONSENSUS.getDenominator(branch, lastPeriod)", 
            "        # sets the amount of rep available for redistribution in the next period", 
            "        if(!CONSENSUS.getFeeFirst(branch, lastPeriod)):", 
            "            CONSENSUS.setFeeFirst(branch, lastPeriod, 1)", 
            "            CONSENSUS.setPeriodBalance(branch, lastPeriod, REPORTING.getRepBalance(branch, branch))", 
            "        gainedRep = newRep * CONSENSUS.getPeriodBalance(branch, lastPeriod) / denominator", 
            "        #if(lostRep) newRep should be == EXPEVENTS.getAfterRep(branch, period, sender) + gainedRep", 
            "        #if(gainedRep) newRep should be == EXPEVENTS.getBeforeRep(branch, period, sender) + gainedRep", 
            "        # give a reporter their portion of redistributed rep", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, sender), gainedRep)", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), gainedRep)", 
            "        cash = BRANCHES.getInitialBalance(branch, lastPeriod) * newRep / denominator", 
            "        # give a reporter their portion of the trading fees", 
            "        CASH.addCash(sender, cash)", 
            "        CASH.subtractCash(branch, cash)", 
            "        CONSENSUS.setFeesCollected(branch, sender, lastPeriod)", 
            "        # return not reported enough bond if not enough penalized is 0 or BRANCHES.getForkPeriod(branch)+1 == lastPeriod during collect fees", 
            "        # todo first period this won't have been paid?", 
            "        if(CONSENSUS.getNotEnoughPenalized(branch, sender, lastPeriod)==0 or BRANCHES.getForkPeriod(branch)+1 == lastPeriod):", 
            "            CONSENSUS.doRefund(sender, sender)", 
            "        # need to pay not reporting bond", 
            "        notReportingBond = msg.value", 
            "        if(notReportingBond < 500000*tx.gasprice):", 
            "            throw()", 
            "        balance = REPORTING.getRepBalance(branch, sender)", 
            "        dormantRep = REPORTING.balanceOf(branch, sender)", 
            "        # Record rep for next report period before any redistributions", 
            "        EXPEVENTS.setBeforeRep(branch, votePeriod, balance, sender)", 
            "        EXPEVENTS.setAfterRep(branch, votePeriod, balance, sender)", 
            "        EXPEVENTS.setPeriodDormantRep(branch, votePeriod, dormantRep, sender)", 
            "        CONSENSUS.setRefund(sender, notReportingBond)", 
            "        send(CONSENSUS, notReportingBond)", 
            "        log(type=collectedFees, branch, sender, cash, CASH.balance(sender), gainedRep, balance, denominator, notReportingBond, lastPeriod, block.timestamp)", 
            "        return(1)", 
            "    else:", 
            "        return(2)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "collectFees(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cashFeesCollected", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "newCashBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "repGain", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "newRepBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "totalReportingRep", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "notReportingBond", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "collectedFees(int256,int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern collectFees: [collectFees:[int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "completeSets": {
        "address": "0x52ccb0490bc81a2ae363fccbb2b367bca546cec7", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [getNumTopicsInBranch:[int256]:int256, getTopicPopularity:[int256,int256]:int256, getTopicsInBranch:[int256,int256,int256]:int256[], getTopicsInfo:[int256,int256,int256]:int256[], test_callstack:[]:int256, updateTopicPopularity:[int256,int256,int256]:int256]", 
            "TOPICS = 0x8caf2c0ce7cdc2e81b58f74322cefdef440b3f8d", 
            "inset('refund.se')", 
            "", 
            "event completeSets_logReturn(sender: indexed, market: indexed, type: indexed, returnValue, numOutcomes, timestamp)", 
            "", 
            "# Buys amount of every outcome", 
            "# cost 850k gas", 
            "# Errors:", 
            "    # 0: invalid market/doesn't exist", 
            "    # -1: oracle only branch [no trading allowed]", 
            "    # -2: not enough money", 
            "def buyCompleteSets(market, amount):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    cost = amount*cumScale/ONE", 
            "    if(!MARKETS.getCreationTime(market)):", 
            "        log(type=completeSets_logReturn, msg.sender, market, 0)", 
            "        return(0)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        log(type=completeSets_logReturn, msg.sender, market, -1)", 
            "        return(-1)", 
            "    if(CASH.balance(msg.sender) < cost):", 
            "        log(type=completeSets_logReturn, msg.sender, market, -2)", 
            "        return(-2)", 
            "    n = 1", 
            "    # Update topic popularity", 
            "    topic = MARKETS.getTopic(market)", 
            "    if topic:", 
            "        TOPICS.updateTopicPopularity(branch, topic, amount*numOutcomes)", 
            "    # send shares of the event to user address and increment the number issued in the market for each outcome", 
            "    while n <= numOutcomes:", 
            "        MARKETS.modifyShares(market, n, amount)", 
            "        MARKETS.modifyParticipantShares(market, msg.sender, n, amount, 0)", 
            "        n += 1", 
            "    # if still before voting period has started count it in the share value for the period and market to target # of reporters to be higher in markets w/ more outstanding value", 
            "    if(BRANCHES.getVotePeriod(branch) < MARKETS.getTradingPeriod(market)):", 
            "        MARKETS.modifySharesValue(market, amount*cumScale/ONE)", 
            "        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount*cumScale/ONE)", 
            "    # send money from user acc. to market address/account", 
            "    CASH.sendFrom(market, cost, msg.sender)", 
            "    log(type=completeSets_logReturn, msg.sender, market, 1, amount, numOutcomes, block.timestamp)", 
            "    return(amount)", 
            "", 
            "# Sells amount of every outcome [if user owns it]", 
            "# cost 850k gas", 
            "# Errors:", 
            "    # -1: oracle only / no trading branch", 
            "    # -2: trader doesn't exist", 
            "    # -3: user doesn't own enough shares", 
            "def sellCompleteSets(market, amount):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    cost = amount*cumScale/ONE", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        log(type=completeSets_logReturn, msg.sender, market, -1)", 
            "        return(-1)", 
            "    n = 1", 
            "    while n <= numOutcomes:", 
            "        if(MARKETS.getParticipantSharesPurchased(market, msg.sender, n) < amount):", 
            "            log(type=completeSets_logReturn, msg.sender, market, -3)", 
            "            return(-3)", 
            "        n += 1", 
            "    n = 1", 
            "    # Update topic popularity", 
            "    topic = MARKETS.getTopic(market)", 
            "    if topic:", 
            "        TOPICS.updateTopicPopularity(branch, topic, -amount*numOutcomes)", 
            "    # Takes shares away from participant and decreases the amount issued in the market since we're exchanging complete sets", 
            "    while n <= numOutcomes:", 
            "        MARKETS.modifyShares(market, n, -amount)", 
            "        MARKETS.modifyParticipantShares(market, msg.sender, n, -amount, 0)", 
            "        n += 1", 
            "    # if still before voting period has started count it in the share value for the period and market to target # of reporters to be higher in markets w/ more outstanding value", 
            "    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):", 
            "        MARKETS.modifySharesValue(market, -amount*cumScale/ONE)", 
            "        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), -amount*cumScale/ONE)", 
            "    # send funds from the market to the user acc.", 
            "    CASH.subtractCash(market, cost)", 
            "    CASH.addCash(msg.sender, cost)", 
            "    log(type=completeSets_logReturn, msg.sender, market, 2, amount, numOutcomes, block.timestamp)", 
            "    return(amount)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "buyCompleteSets(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "sellCompleteSets(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "returnValue", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "completeSets_logReturn(int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern completeSets: [buyCompleteSets:[int256,int256]:int256, sellCompleteSets:[int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "compositeGetters": {
        "address": "0xcece47d6c0a6a1c90521f38ec5bf7550df983804", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getBestAskID:[int256,int256]:int256, getBestBidID:[int256,int256]:int256, getID:[int256]:int256, getSender:[]:int256, getTradeOwner:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], get_trade_block:[int256]:int256, makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]", 
            "TRADES = 0xd70c6e1f3857d23bd96c3e4d2ec346fa7c3931f3", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern proportionCorrect: [proportionCorrect:[int256]:int256, test_callstack:[]:int256]", 
            "PROPORTION = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "inset('refund.se')", 
            "", 
            "macro TRADE_FIELDS: 8", 
            "macro EVENTS_FIELDS: 9", 
            "macro OUTCOMES_FIELDS: 3", 
            "macro BASE_FIELDS: 15", 
            "macro BASE_CACHE_FIELDS: 10", 
            "", 
            "def getOrderBook(marketID, offset, numTradesToLoad):", 
            "    refund()", 
            "    numTrades = MARKETS.get_total_trades(marketID)", 
            "    if offset > numTrades:", 
            "        return([]: arr)", 
            "    if numTradesToLoad == 0:", 
            "        numTradesToLoad = numTrades", 
            "    totalTrades = min(numTradesToLoad, numTrades - offset)", 
            "    trades = MARKETS.get_trade_ids(marketID, offset, numTrades, outitems=numTrades)", 
            "    orderBook = array(TRADE_FIELDS*totalTrades)", 
            "    numAvailableTrades = 0", 
            "    i = 0", 
            "    while i < totalTrades:", 
            "        tradeInfo = TRADES.get_trade(trades[i], outitems=TRADE_FIELDS)", 
            "        if tradeInfo[0] != 0:", 
            "            j = 0", 
            "            while j < 8:", 
            "                orderBook[8*numAvailableTrades + j] = tradeInfo[j]", 
            "                j += 1", 
            "            numAvailableTrades += 1", 
            "        i += 1", 
            "    return(slice(orderBook, items=0, items=TRADE_FIELDS*numAvailableTrades): arr)", 
            "", 
            "def getAccountOrderBook(marketID, account):", 
            "    refund()", 
            "    numTrades = MARKETS.get_total_trades(marketID)", 
            "    trades = MARKETS.get_trade_ids(marketID, 0, 0, outitems=numTrades)", 
            "    orderBook = array(TRADE_FIELDS*numTrades)", 
            "    numAccountTrades = 0", 
            "    i = 0", 
            "    while i < numTrades:", 
            "        owner = TRADES.getTradeOwner(trades[i])", 
            "        if owner == account:", 
            "            tradeInfo = TRADES.get_trade(trades[i], outitems=TRADE_FIELDS)", 
            "            if tradeInfo[0] != 0:", 
            "                j = 0", 
            "                while j < 8:", 
            "                    orderBook[8*numAccountTrades + j] = tradeInfo[j]", 
            "                    j += 1", 
            "                numAccountTrades += 1", 
            "        i += 1", 
            "    return(slice(orderBook, items=0, items=TRADE_FIELDS*numAccountTrades): arr)", 
            "", 
            "def getMarketInfo(marketID, account):", 
            "    refund()", 
            "    index = BASE_FIELDS", 
            "    eventID = MARKETS.getMarketEvent(marketID, 0)", 
            "    descriptionLength = INFO.getDescriptionLength(eventID)", 
            "    resolutionLength = EVENTS.getResolutionLength(eventID)", 
            "    extraInfoLength = MARKETS.getExtraInfoLength(marketID)", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(marketID)", 
            "    marketInfo = array(BASE_FIELDS + EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + descriptionLength + resolutionLength + extraInfoLength + 3)", 
            "    marketInfo[0] = marketID", 
            "    marketInfo[1] = MARKETS.getMakerFees(marketID)", 
            "    marketInfo[2] = numOutcomes", 
            "    marketInfo[3] = MARKETS.getTradingPeriod(marketID)", 
            "    marketInfo[4] = MARKETS.getTradingFee(marketID)", 
            "    marketInfo[5] = MARKETS.getBranchID(marketID)", 
            "    marketInfo[6] = MARKETS.getCumScale(marketID)", 
            "    marketInfo[7] = MARKETS.getCreationTime(marketID)", 
            "    marketInfo[8] = MARKETS.getCreationBlock(marketID)", 
            "    marketInfo[9] = MARKETS.getVolume(marketID)", 
            "    marketInfo[10] = INFO.getCreationFee(marketID)", 
            "    marketInfo[11] = INFO.getCreator(marketID)", 
            "    tags = MARKETS.returnTags(marketID, outitems=3)", 
            "    marketInfo[12] = tags[0]", 
            "    marketInfo[13] = tags[1]", 
            "    marketInfo[14] = tags[2]", 
            "", 
            "    # gather event(s) info:", 
            "    # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]", 
            "    eventInfo = EVENTS.getEventInfo(eventID, outitems=EVENTS_FIELDS - 2)", 
            "    marketInfo[index] = eventID", 
            "    j = 1", 
            "    while j < EVENTS_FIELDS - 2:", 
            "        marketInfo[index + j] = eventInfo[j]", 
            "        j += 1", 
            "    marketInfo[index + EVENTS_FIELDS - 2] = EVENTS.getEthical(eventID)", 
            "    marketInfo[index + EVENTS_FIELDS - 1] = PROPORTION.proportionCorrect(eventID)", 
            "    index += EVENTS_FIELDS", 
            "", 
            "    # gather outcomes info: [sharesPurchased, price]", 
            "    # (price of outcome = last trade)", 
            "    k = 0", 
            "    while k < numOutcomes:", 
            "        marketInfo[index + k*OUTCOMES_FIELDS] = MARKETS.getSharesPurchased(marketID, k + 1)", 
            "        marketInfo[index + k*OUTCOMES_FIELDS + 1] = MARKETS.getLastOutcomePrice(marketID, k + 1)", 
            "        if account != 0:", 
            "            marketInfo[index + k*OUTCOMES_FIELDS + 2] = MARKETS.getParticipantSharesPurchased(marketID, account, k + 1)", 
            "        k += 1", 
            "    index += numOutcomes*OUTCOMES_FIELDS", 
            "", 
            "    # append description character codes", 
            "    marketInfo[index] = descriptionLength", 
            "    index += 1", 
            "    description = INFO.getDescription(eventID, outchars=descriptionLength)", 
            "    c = 0", 
            "    while c < descriptionLength:", 
            "        marketInfo[index + c] = getch(description, c)", 
            "        c += 1", 
            "    index += descriptionLength", 
            "", 
            "    # append resolution character codes", 
            "    marketInfo[index] = resolutionLength", 
            "    index += 1", 
            "    resolution = EVENTS.getResolution(eventID, outchars=resolutionLength)", 
            "    c = 0", 
            "    while c < resolutionLength:", 
            "        marketInfo[index + c] = getch(resolution, c)", 
            "        c += 1", 
            "    index += resolutionLength", 
            "", 
            "    # append extraInfo character codes", 
            "    marketInfo[index] = extraInfoLength", 
            "    index += 1", 
            "    extraInfo = MARKETS.getExtraInfo(marketID, outchars=extraInfoLength)", 
            "    c = 0", 
            "    while c < extraInfoLength:", 
            "        marketInfo[index + c] = getch(extraInfo, c)", 
            "        c += 1", 
            "", 
            "    return(marketInfo: arr)", 
            "", 
            "def batchGetMarketInfo(marketIDs: arr, account):", 
            "    refund()", 
            "    numMarkets = len(marketIDs)", 
            "    totalLength = 0", 
            "    marketInfoLength = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        marketID = marketIDs[i]", 
            "        eventID = MARKETS.getMarketEvent(marketID, 0)", 
            "        descriptionLength = INFO.getDescriptionLength(eventID)", 
            "        resolutionLength = EVENTS.getResolutionLength(eventID)", 
            "        extraInfoLength = MARKETS.getExtraInfoLength(marketID)", 
            "        numOutcomes = MARKETS.getMarketNumOutcomes(marketID)", 
            "        marketInfoLength[i] = BASE_FIELDS + EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + descriptionLength + resolutionLength + extraInfoLength + 4", 
            "        totalLength += marketInfoLength[i]", 
            "        i += 1", 
            "    marketsInfo = array(totalLength)", 
            "    index = 0", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        marketInfo = self.getMarketInfo(marketIDs[i], account, outitems=marketInfoLength[i] - 1)", 
            "        marketsInfo[index] = marketInfoLength[i]", 
            "        j = 0", 
            "        while j < marketInfoLength[i] - 1:", 
            "            marketsInfo[index + j + 1] = marketInfo[j]", 
            "            j += 1", 
            "        index += marketInfoLength[i]", 
            "        i += 1", 
            "    return(marketsInfo: arr)", 
            "", 
            "# - if both volumeMin and volumeMax are specified, then", 
            "#   only include markets in the half-open interval: (volumeMin, volumeMax]", 
            "# - if volumeMax = -1 then there is no upper limit", 
            "def getMarketsInfo(branch, offset, numMarketsToLoad, volumeMin, volumeMax):", 
            "    refund()", 
            "    numMarkets = BRANCHES.getNumMarketsBranch(branch)", 
            "    if offset > numMarkets:", 
            "        return([]: arr)", 
            "    if numMarketsToLoad == 0:", 
            "        numMarketsToLoad = numMarkets", 
            "    totalMarkets = min(numMarketsToLoad, numMarkets - offset)", 
            "    marketIDs = BRANCHES.getSomeMarketsInBranch(branch, offset, offset + totalMarkets, outitems=totalMarkets)", 
            "", 
            "    if volumeMin < volumeMax or volumeMax == -1:", 
            "        numThresholdedMarkets = 0", 
            "        thresholdedMarketIDs = array(numMarkets)", 
            "        m = 0", 
            "        while m < totalMarkets:", 
            "            marketID = marketIDs[m]", 
            "            volume = MARKETS.getVolume(marketID)", 
            "            if volume > volumeMin and (volumeMax == -1 or volume <= volumeMax):", 
            "                thresholdedMarketIDs[numThresholdedMarkets] = marketID", 
            "                numThresholdedMarkets += 1", 
            "                if numThresholdedMarkets == totalMarkets:", 
            "                    m = totalMarkets - 1", 
            "            m += 1", 
            "        totalMarkets = min(numThresholdedMarkets, totalMarkets)", 
            "        marketIDs = slice(thresholdedMarketIDs, items=0, items=numThresholdedMarkets)", 
            "", 
            "    descriptionLengths = array(totalMarkets)", 
            "    totalLen = totalMarkets*16", 
            "    m = 0", 
            "    while m < totalMarkets:", 
            "        eventID = MARKETS.getMarketEvent(marketIDs[m], 0)", 
            "        descriptionLengths[m] = INFO.getDescriptionLength(eventID)", 
            "        totalLen += descriptionLengths[m]", 
            "        m += 1", 
            "    marketsInfo = array(totalLen + 1)", 
            "    marketsInfo[0] = totalMarkets", 
            "", 
            "    # get basic market info for each market", 
            "    m = 0", 
            "    c = 1", 
            "    while m < totalMarkets:", 
            "        marketID = marketIDs[m]", 
            "        descriptionLength = descriptionLengths[m]", 
            "        marketsInfo[c] = 16 + descriptionLength", 
            "        marketsInfo[c + 1] = marketID", 
            "        marketsInfo[c + 2] = MARKETS.getTradingPeriod(marketID)", 
            "        marketsInfo[c + 3] = MARKETS.getTradingFee(marketID)", 
            "        marketsInfo[c + 4] = MARKETS.getCreationTime(marketID)", 
            "        marketsInfo[c + 5] = MARKETS.getVolume(marketID)", 
            "        tags = MARKETS.returnTags(marketID, outitems=3)", 
            "        marketsInfo[c + 6] = tags[0]", 
            "        marketsInfo[c + 7] = tags[1]", 
            "        marketsInfo[c + 8] = tags[2]", 
            "        marketsInfo[c + 9] = MARKETS.getLastExpDate(marketID)", 
            "        marketsInfo[c + 10] = MARKETS.getMakerFees(marketID)", 
            "        eventID = MARKETS.getMarketEvent(marketID, 0)", 
            "        marketsInfo[c + 11] = eventID", 
            "        marketsInfo[c + 12] = EVENTS.getMinValue(eventID)", 
            "        marketsInfo[c + 13] = EVENTS.getMaxValue(eventID)", 
            "        marketsInfo[c + 14] = EVENTS.getNumOutcomes(eventID)", 
            "        marketsInfo[c + 15] = EVENTS.getOutcome(eventID)", 
            "        description = INFO.getDescription(eventID, outchars=descriptionLength)", 
            "        c += 16", 
            "        d = 0", 
            "        while d < descriptionLength:", 
            "            marketsInfo[c] = getch(description, d)", 
            "            c += 1", 
            "            d += 1", 
            "        m += 1", 
            "    return(marketsInfo: arr)", 
            "", 
            "def getMarketCreatorFeesCollected(market):", 
            "    return((MARKETS.getFees(market) - INFO.getCreationFee(market))/2)", 
            "", 
            "def getEventsWithSubmittedReport(branch, period, reporter):", 
            "    self.test_callstack()", 
            "    numEvents = EXPEVENTS.getNumberEvents(branch, period)", 
            "    events = array(numEvents)", 
            "    n = 0", 
            "    i = 0", 
            "    while(i < numEvents):", 
            "        eventID = EXPEVENTS.getEvent(branch, period, i)", 
            "        if(EXPEVENTS.getReport(branch, period, eventID, reporter) != 0):", 
            "            events[n] = eventID", 
            "            n += 1", 
            "        i += 1", 
            "    return(slice(events, items=0, items=n): arr)", 
            "", 
            "def getPositionInMarket(market, account):", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "    position = array(numOutcomes)", 
            "    i = 0", 
            "    while i < numOutcomes:", 
            "        position[i] = MARKETS.getParticipantSharesPurchased(market, account, i + 1)", 
            "        i += 1", 
            "    return(position: arr)", 
            "", 
            "def getMarketsCreatedByMarketCreator(branch, creator, initial, last):", 
            "    if(last < initial):", 
            "        throw()", 
            "    markets = array(last - initial)", 
            "    marketsByCreator = array(last - initial)", 
            "    markets = BRANCHES.getSomeMarketsInBranch(branch, initial, last, outitems = (last - initial))", 
            "    i = 0", 
            "    n = 0", 
            "    while i < len(markets):", 
            "        if(INFO.getCreator(markets[i]) == creator):", 
            "            marketsByCreator[n] = markets[i]", 
            "            n += 1", 
            "        i += 1", 
            "    marketsByCreator = slice(marketsByCreator, items = 0, items = n)", 
            "    return(marketsByCreator: arr)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketIDs", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "batchGetMarketInfo(int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "getAccountOrderBook(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventsWithSubmittedReport(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketCreatorFeesCollected(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketInfo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "creator", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initial", 
                        "type": "int256"
                    }, 
                    {
                        "name": "last", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsCreatedByMarketCreator(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numMarketsToLoad", 
                        "type": "int256"
                    }, 
                    {
                        "name": "volumeMin", 
                        "type": "int256"
                    }, 
                    {
                        "name": "volumeMax", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInfo(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numTradesToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getOrderBook(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "getPositionInMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern compositeGetters: [batchGetMarketInfo:[int256[],int256]:int256[], getAccountOrderBook:[int256,int256]:int256[], getEventsWithSubmittedReport:[int256,int256,int256]:int256[], getMarketCreatorFeesCollected:[int256]:int256, getMarketInfo:[int256,int256]:int256[], getMarketsCreatedByMarketCreator:[int256,int256,int256,int256]:int256[], getMarketsInfo:[int256,int256,int256,int256,int256]:int256[], getOrderBook:[int256,int256,int256]:int256[], getPositionInMarket:[int256,int256]:int256[], test_callstack:[]:int256]"
    }, 
    "consensus": {
        "address": "0x6c4c9fa11d6d8ed2c7a08ddcf4d4654c85194f68", 
        "code": [
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern proportionCorrect: [proportionCorrect:[int256]:int256, test_callstack:[]:int256]", 
            "PROPORTION = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern closeMarket: [claimProceeds:[int256,int256]:int256, closeMarket:[int256,int256,int256]:_, test_callstack:[]:int256]", 
            "CLOSEMARKET = 0xc1c4e2f32e4b84a60b8b7983b6356af4269aab79", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "inset('refund.se')", 
            "inset('logReturn.se')", 
            "", 
            "# p: proportion correct", 
            "event penalize(sender: indexed, branch: indexed, event: indexed, outcome, oldrep, repchange, p, reportValue, penalizedUpTo, timestamp)", 
            "event consensus_logReturn(returnValue)", 
            "", 
            "macro POINTZEROONE: 10000000000000000", 
            "macro POINTEIGHT: 800000000000000000", 
            "macro POINTTWO: 200000000000000000", 
            "", 
            "# Penalizes a reporter for reporting wrongly on an event", 
            "    # examples from the start of a new branch:", 
            "        # ex:", 
            "            #period 0 voteperiod -1 - last period penalized should be -1 or starting vote period", 
            "            #add some events to period 0", 
            "            #increment", 
            "            #period 1 voteperiod 0 - shouldn't be penalizing anything yet b/c still reporting on period 0", 
            "            #increment", 
            "            #period 2 voteperiod 1 - penalize on events in voteperiod 0", 
            "        # ex 2:", 
            "            #currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period", 
            "            #add some events to period 100", 
            "            #increment to period 101", 
            "            #period 101, voteperiod 100 - shouldn't be penalizing anything yet", 
            "            #increment", 
            "            #period 102, voteperiod 101 - penalize on events in voteperiod 100", 
            "#1. Record rep at start of report period [before rep in make reports]", 
            "#2. Penalize for each event", 
            "#3. Each reporter needs to do this for all events they reported on, if not get docked", 
            "#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees", 
            "#5. If a reporter doesn't do it for all events, they autolose 10% rep each period one doesn't do it (b/c they're trying to cheat)", 
            "# Errors:", 
            "    #  0: event is a fork event", 
            "    # -1: need to penalize in round 2 penalize function", 
            "    # -2: already past first half of new period and needed to penalize before then", 
            "    # -4: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize", 
            "    # -5: already done for all events in this period", 
            "    # -6: forked events should be penalized using the fork penalization function", 
            "    # -7: no outcome", 
            "    # -8: needed to collect fees last period which sets the before/after rep", 
            "# force event to be resolved first if it can be", 
            "def penalizeWrong(branch, event):", 
            "    refund()", 
            "    repBalance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    newRep = 0", 
            "    rejected = EVENTS.getRejected(event)", 
            "    newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)", 
            "    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)", 
            "    roundTwo = BACKSTOPS.getRoundTwo(event)", 
            "    uncaught = EVENTS.getUncaughtOutcome(event)", 
            "    if(!CONSENSUS.getFeesCollected(branch, msg.sender, lastPeriod-1)):", 
            "        logReturn(consensus_logReturn, -8)", 
            "    if(repBalance < ONE):", 
            "        logReturn(consensus_logReturn, 0)", 
            "    if(CONSENSUS.getPenalizedUpTo(branch, msg.sender)==lastPeriod):", 
            "        logReturn(consensus_logReturn, -5)", 
            "    if(BRANCHES.getForkPeriod(branch) == lastPeriod):", 
            "        logReturn(consensus_logReturn, -4)", 
            "    elif(EVENTS.getForked(event)):", 
            "        logReturn(consensus_logReturn, -6)", 
            "    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]", 
            "    elif(!uncaught && EVENTS.getEventBranch(event) == branch && !(rejected && EVENTS.getRejectedPeriod(event)==lastPeriod)):", 
            "        if(CLOSEMARKET.closeMarket(branch, EVENTS.getMarket(event, 0), msg.sender)!=1):", 
            "            logReturn(consensus_logReturn, -7)", 
            "", 
            "    outcome = catch(uncaught)", 
            "    if(scalar(event) or categorical(event)):", 
            "        outcome = uncaught", 
            "    p = PROPORTION.proportionCorrect(event)", 
            "    if(roundTwo && outcome!=0):", 
            "        logReturn(consensus_logReturn, -1)", 
            "    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)", 
            "    numReportedOn = EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)", 
            "    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period", 
            "    # commented for testing", 
            "    #elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):", 
            "    #    logReturn(consensus_logReturn, -2)", 
            "    # lastperiod is where people who originally voted on a round 2 event voted the first time - want num events penalized to go up but not to actually be penalized for it yet", 
            "        # shouldn't be penalized until the next period resolution is over [since it's a round 2 event]", 
            "    if(roundTwo && !CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue):", 
            "        CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)", 
            "        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)", 
            "        # if a person reported on a round 2 event, they cannot convert their rep to dormant or send rep until they've finished the resolution process for that round 2 event todo", 
            "            # unless this just happened to them last period and they reported correctly then", 
            "    # if this event was a pushed forward event that got rejected, don't penalize on it, only penalize on the final reporting, i.e. if appealed don't allow rep redistribution until after the appeal process is over in the first period", 
            "    elif(!CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue && rejected && EVENTS.getRejectedPeriod(event)==lastPeriod):", 
            "        CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)", 
            "        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)", 
            "    # penalization on a regular event if not already penalized, it has outcome, and user reported on it", 
            "    elif(!CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue && outcome!=0):", 
            "        # wrong", 
            "        if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):", 
            "            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                diff = reportValue - outcome", 
            "                p = -(abs(diff)/2) + ONE", 
            "            newRep = oldRep*(2*p - ONE)/ONE", 
            "        # right", 
            "        else:", 
            "            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                diff = reportValue - outcome", 
            "                # perhaps for right we should do diff todo so adds to more than 1 --- can actually do proportion correct for this i think now", 
            "                p = -(abs(diff)/2) + ONE", 
            "            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE", 
            "        # (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period) for penalization and pen. rate for forking and backstop 1", 
            "        # use .02 as a max penalty per event", 
            "        if(numReportedOn<10):", 
            "            repChange = oldRep * (ONE - POINTTWO/10)/ONE + newRep*(POINTTWO/10)/ONE - oldRep", 
            "        else:", 
            "            repChange = oldRep * (ONE - POINTTWO/numReportedOn)/ONE + newRep*(POINTTWO/numReportedOn)/ONE - oldRep", 
            "        newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange", 
            "        log(type=penalize, msg.sender, branch, event, outcome, oldRep, repChange, p, reportValue, lastPeriod, block.timestamp)", 
            "        EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "        CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)", 
            "        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)", 
            "    # once penalized for all events actually get rid of net rep lost and send it to the branch for redistribution", 
            "    if(numReportedOn==CONSENSUS.getPenalizedNum(branch, lastPeriod, msg.sender)):", 
            "        if(newAfterRep <= 0):", 
            "            newAfterRep = 0", 
            "            EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, msg.sender, lastPeriod)", 
            "        CONSENSUS.increaseDenominator(branch, lastPeriod, newAfterRep)", 
            "        totalRepDifference = newAfterRep - oldRep", 
            "        if(repBalance + totalRepDifference <= 0):", 
            "            totalRepDifference = -1*repBalance", 
            "        if(totalRepDifference<0):", 
            "            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]", 
            "            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)", 
            "            # sends that rep to the branch", 
            "            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)", 
            "    logReturn(consensus_logReturn, 1)", 
            "", 
            "# Increments the period after reporting", 
            "# ui has to call this to stay cheap / not check it elsewhere", 
            "def incrementPeriodAfterReporting(branch):", 
            "    refund()", 
            "    # do this after reporting is finished", 
            "    if(periodOver(branch)):", 
            "        period = block.timestamp / BRANCHES.getPeriodLength($branch) - 1", 
            "        lastPeriod = period - 1", 
            "        percentAppealed = (EXPEVENTS.getNumRoundTwo(branch, period)*ONE/EXPEVENTS.getNumberEvents(branch, period) + EXPEVENTS.getNumRoundTwo(branch, lastPeriod)*ONE/EXPEVENTS.getNumberEvents(branch, lastPeriod)) / 2", 
            "        BRANCHES.incrementPeriod(branch)", 
            "        # mult. by 2 b/c reporters only have to report on half the things they're selected to report on", 
            "        base_reporter_quantity = 2*(3*ONE + ((333*ONE * Percent_Appealed/ONE)**3 / 2**128))/ONE", 
            "        CONSENSUS.setBaseReportersLastPeriod(branch, BRANCHES.getBaseReporters(branch))", 
            "        BRANCHES.setBaseReporters(branch, base_reporter_quantity)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "### Helper functions:", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "macro periodOver($branch):", 
            "    # what the current vote period should be", 
            "    currentVotePeriod = block.timestamp / BRANCHES.getPeriodLength($branch) - 1", 
            "    # if actual vote period is less than what the current one should be, return 1, it can be incremented", 
            "    if(BRANCHES.getVotePeriod($branch) < currentVotePeriod):", 
            "        1", 
            "    else:", 
            "        0", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriodAfterReporting(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeWrong(int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": false, 
                        "name": "returnValue", 
                        "type": "int256"
                    }
                ], 
                "name": "consensus_logReturn(int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "oldrep", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "repchange", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "p", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "reportValue", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "penalizedUpTo", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "penalize(int256,int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern consensus: [incrementPeriodAfterReporting:[int256]:int256, penalizeWrong:[int256,int256]:_, test_callstack:[]:int256]"
    }, 
    "consensusData": {
        "address": "0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "inset('refund.se')", 
            "", 
            "# Storage for branch data", 
            "# branch takes a branchID", 
            "    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total", 
            "    # penalizedUpTo is the latest period a user has done the penalization for", 
            "    # fees collected states whether for a given period a user collected fees", 
            "    # rep collected states whether for a given period a user collected rep", 
            "    # base reporters last period is the minimum number of reporters for the last period", 
            "data branch[](period[](denominator, penalized[](event[], num, notEnoughReportsPenalized), feesCollected[], feeFirst, periodBalance), penalizedUpTo[], baseReportersLastPeriod)", 
            "", 
            "# refunds keeps track of subsidies for various consensus function calls paid for by the market creator or bonders", 
            "data refunds[]", 
            "", 
            "# Keeps track of whether a reporter has been penalized for collusion while reporting", 
            "data slashed[][](reporter[])", 
            "", 
            "def init():", 
            "    self.branch[1010101].baseReportersLastPeriod = 2*3", 
            "", 
            "def getSlashed(branch, votePeriod, reporter):", 
            "    return(self.slashed[branch][votePeriod].reporter[reporter])", 
            "", 
            "def setSlashed(branch, votePeriod, reporter):", 
            "    self.slashed[branch][votePeriod].reporter[reporter] = 1", 
            "    return(1)", 
            "", 
            "def setRefund(refunder, amt):", 
            "    self.refunds[refunder] = amt", 
            "    return(1)", 
            "", 
            "def doRefund(sender, refunder):", 
            "    send(sender, self.refunds[refunder])", 
            "    return(1)", 
            "", 
            "def getBaseReportersLastPeriod(branch):", 
            "    return(self.branch[branch].baseReportersLastPeriod)", 
            "", 
            "def setBaseReportersLastPeriod(branch, amount):", 
            "    self.branch[branch].baseReportersLastPeriod = amount", 
            "    return(1)", 
            "", 
            "# get whether the first fee has been claimed by a reporter yet", 
            "def getFeeFirst(branch, period):", 
            "    return(self.branch[branch].period[period].feeFirst)", 
            "", 
            "def setFeeFirst(branch, period, val):", 
            "    self.branch[branch].period[period].feeFirst = val", 
            "    return(1)", 
            "", 
            "def getPeriodBalance(branch, period):", 
            "    return(self.branch[branch].period[period].periodBalance)", 
            "", 
            "def setPeriodBalance(branch, period, balance):", 
            "    self.branch[branch].period[period].periodBalance = balance", 
            "", 
            "def getPenalizedUpTo(branch, sender):", 
            "    return(self.branch[branch].penalizedUpTo[sender])", 
            "", 
            "def setPenalizedUpTo(branch, sender, period):", 
            "    self.branch[branch].penalizedUpTo[sender] = period", 
            "    return(1)", 
            "", 
            "def getDenominator(branch, period):", 
            "    return(self.branch[branch].period[period].denominator)", 
            "", 
            "def increaseDenominator(branch, period, amount):", 
            "    self.branch[branch].period[period].denominator += amount", 
            "    return(1)", 
            "", 
            "def getFeesCollected(branch, address, period):", 
            "    return(self.branch[branch].period[period].feesCollected[address])", 
            "", 
            "def setFeesCollected(branch, address, period):", 
            "    self.branch[branch].period[period].feesCollected[address] = 1", 
            "    return(1)", 
            "", 
            "def getPenalized(branch, period, sender, event):", 
            "    return(self.branch[branch].period[period].penalized[sender].event[event])", 
            "", 
            "def setPenalized(branch, period, sender, event):", 
            "    self.branch[branch].period[period].penalized[sender].event[event] = 1", 
            "    return(1)", 
            "", 
            "def getPenalizedNum(branch, period, sender):", 
            "    return(self.branch[branch].period[period].penalized[sender].num)", 
            "", 
            "def increasePenalizedNum(branch, period, sender, amount):", 
            "    self.branch[branch].period[period].penalized[sender].num += amount", 
            "    return(1)", 
            "", 
            "def setNotEnoughPenalized(branch, address, period):", 
            "    self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized = 1", 
            "    return(1)", 
            "", 
            "def getNotEnoughPenalized(branch, address, period):", 
            "    return(self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized)", 
            "", 
            "def getRepRedistributionDone(branch, reporter):", 
            "    refund()", 
            "    return(repRedistributionDone(branch, reporter))", 
            "", 
            "macro repRedistributionDone($branch, $reporter):", 
            "    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]", 
            "    lastPeriod = BRANCHES.getVotePeriod($branch)-1", 
            "    if(lastPeriod==lastPeriodPenalized):", 
            "        1", 
            "    else:", 
            "        0"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "refunder", 
                        "type": "int256"
                    }
                ], 
                "name": "doRefund(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getBaseReportersLastPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getDenominator(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getFeeFirst(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getFeesCollected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNotEnoughPenalized(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getPenalized(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getPenalizedNum(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getPenalizedUpTo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepRedistributionDone(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getSlashed(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "increaseDenominator(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "increasePenalizedNum(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "setBaseReportersLastPeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "val", 
                        "type": "int256"
                    }
                ], 
                "name": "setFeeFirst(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setFeesCollected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setNotEnoughPenalized(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setPenalized(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setPenalizedUpTo(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setPeriodBalance(int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "refunder", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amt", 
                        "type": "int256"
                    }
                ], 
                "name": "setRefund(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "setSlashed(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "createBranch": {
        "address": "0x9fe69262bbaa47f013b7dbd6ca5f01e17446c645", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "inset('refund.se')", 
            "", 
            "# Create a new branch given a parent branch - a branch is essentially a fork of rep where new markets can be created", 
            "# period length is given in seconds", 
            "# @return branchID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: no money for creation fee", 
            "    # -3: branch already exists", 
            "def createSubbranch(description:str, periodLength, parent, minTradingFee, oracleOnly):", 
            "    refund()", 
            "    if(periodLength<=0 || !BRANCHES.getPeriodLength(parent) || description==0):", 
            "        return(-1)", 
            "    if(minTradingFee < 0 or minTradingFee > 2**62):", 
            "        return(-1)", 
            "    parentPeriod = BRANCHES.getVotePeriod(parent)", 
            "    branchInfo = string(7*32+len(description))", 
            "    branchInfo[0] = msg.sender", 
            "    #creation fee", 
            "    branchInfo[1] = 47*ONE", 
            "    #length of voting cycle", 
            "    branchInfo[2] = periodLength", 
            "    branchInfo[3] = block.timestamp", 
            "    branchInfo[4] = parent", 
            "    branchInfo[5] = minTradingFee", 
            "    branchInfo[6] = oracleOnly", 
            "    mcopy(branchInfo + 7*32, description, chars=len(description))", 
            "    # people can check that these characteristics hash to the ID if they want", 
            "    # people can hand a friend their new branch hash && characteristics && say, \"don't trust me? check\"", 
            "    branchID = sha3(branchInfo, chars=len(branchInfo))", 
            "    currentVotePeriod = (block.timestamp / periodLength) - 1", 
            "    if(CASH.balance(msg.sender)<47*ONE):", 
            "        return(-2)", 
            "    # provided event doesn't already exist, create it", 
            "    if(INFO.getCreator(branchID)==0):", 
            "        BRANCHES.initializeBranch(branchID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent)", 
            "    else:", 
            "        return(-3)", 
            "    # pay creation fee, initialize branch info", 
            "    if(CASH.sendFrom(parent, 47*ONE, msg.sender) && INFO.setInfo(branchID, description, tx.origin, 47*ONE) && REPORTING.setInitialReporters(parent, branchID)):", 
            "        return(branchID)", 
            "    else:", 
            "        return(-2)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minTradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }
                ], 
                "name": "createSubbranch(bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createBranch: [createSubbranch:[bytes,int256,int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "createMarket": {
        "address": "0x448c01a2e1fd6c2ef133402c403d2f48c99993e7", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "inset('refund.se')", 
            "", 
            "macro POINTONETWOFIVE: 125000000000000000", 
            "macro POINTZEROSIX: 60000000000000000", 
            "macro COSTPERREPORTER: 3500000", 
            "", 
            "event marketCreated(sender: indexed, marketID: indexed, topic: indexed, branch, marketCreationFee, eventBond, timestamp)", 
            "event tradingFeeUpdated(sender: indexed, branch: indexed, marketID: indexed, tradingFee, timestamp)", 
            "", 
            "def createSingleEventMarket(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution:str, tradingFee, tag1, tag2, tag3, makerFees, extraInfo:str):", 
            "    eventID = self.createEvent(branch, description, expDate, minValue, maxValue, numOutcomes, resolution, call=delegate)", 
            "    marketID = self.createMarket(branch, tradingFee, eventID, tag1, tag2, tag3, makerFees, extraInfo, call=delegate)", 
            "    return(marketID)", 
            "", 
            "# Create an event. Events are the basic units / questions that are reported on in Augur by reporters", 
            "# @param numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0 to 11.0 would be 11 outcomes (if incremented by 0.1)", 
            "# @param minValue should be 10**18 for a binary event, maxValue should be 2*10**18 for a binary event", 
            "# @param minValue for a scalar from 0 to 100 should be 0 and max should be 100*10**18, for -100 to 200, it should be -100*10**18 and 200*10**18 respectively", 
            "# @param description is a description of the event / the question itself", 
            "# @param resolution is the string source/link to resolve the event", 
            "# @param branch is the branch the event is created in", 
            "# @param expDate is the epoch time in which the event expires", 
            "# @return eventID if success", 
            "# error messages otherwise", 
            "    #  0: not enough money to pay fees or event already exists", 
            "    # -1: we're either already past that date, branch doesn't exist, or description is bad", 
            "    # -2: max value < min value or range < 1", 
            "    # -3: invalid number of outcomes", 
            "    # -4: would expire during non-reporting fork period", 
            "# .025 eth to create", 
            "def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    if(!periodLength or description == 0 or expDate < block.timestamp):", 
            "        return(-1)", 
            "    if(maxValue < minValue or (maxValue-minValue) < ONE):", 
            "        return(-2)", 
            "    if(numOutcomes < 2 || numOutcomes > 8):", 
            "        return(-3)", 
            "    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):", 
            "        return(-4)", 
            "    eventinfo = string(7*32 + len(description))", 
            "    eventinfo[0] = branch                                       #branchID", 
            "    eventinfo[1] = expDate                                      #expiration date", 
            "    eventinfo[2] = msg.sender                                   #creator address", 
            "    eventinfo[3] = periodLength", 
            "    eventinfo[4] = minValue                                     #minimum outcome value", 
            "    eventinfo[5] = maxValue                                     #maximum outcome value", 
            "    eventinfo[6] = numOutcomes                                  #number of outcomes", 
            "    mcopy(eventinfo + 7*32, description, len(description))", 
            "    eventID = sha3(eventinfo, chars=len(eventinfo))", 
            "    CASH.initiateOwner(eventID)", 
            "    if(INFO.getCreator(eventID)):", 
            "        return(0)", 
            "    if(INFO.setInfo(eventID, description, msg.sender, 0) && EVENTS.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):", 
            "        return(eventID)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# Create a market. Markets are the basic _tradable_ units / questions that are traded on in Augur", 
            "# @param branch is the branch of the market", 
            "# @param tradingFee is percent in fixedPoint", 
            "# @param events array is the list of events in a market [up to 3]", 
            "# @params tag1, tag2, and tag3 are the tags describing a market (tag1 is the \"main topic\")", 
            "# @param makerFees are the percent of the trading fee a maker pays [0-50% in fixed point]", 
            "# @param extraInfo is a string of any extra info associated with a market", 
            "# @return marketID if success or 1 if on an oracle only branch creation we have success", 
            "# error messages otherwise", 
            "    # -1: bad input or event doesn't exist", 
            "    # -2: event already expired", 
            "    # -3: would expire during non-reporting fork period", 
            "    # -4: market already exists", 
            "    # throws if not enough money to create the market and place event in the appropriate reporting period", 
            "# .05 eth to create", 
            "# need at least 1.2M gas @ gas price to cover resolution 500k per event to calc. num reports for it - this is passed as value to this function", 
            "# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)", 
            "def createMarket(branch, tradingFee, event, tag1, tag2, tag3, makerFees, extraInfo:str):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    creationFee = POINTZEROSIX * BRANCHES.getBaseReporters(branch) * ONE / (2*tradingFee)", 
            "    # gives ether/cash amount in fixed point", 
            "    minFee = COSTPERREPORTER*BRANCHES.getBaseReporters(branch)*tx.gasprice", 
            "    if(creationFee < minFee):", 
            "        creationFee = minFee", 
            "    validity_bond = (creationFee * (1 + EVENTS.getPast24(block.timestamp / periodLength)) / (1 + EXPEVENTS.getNumberEvents(branch, BRANCHES.getVotePeriod(branch))))/2", 
            "    numOutcomes = EVENTS.getNumOutcomes(event)", 
            "    cumulativeScale = 0", 
            "    # market's trading period is the same as the last expiring event in the market", 
            "    expirationDate = EVENTS.getExpiration(event)", 
            "    futurePeriod = expirationDate / periodLength", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets", 
            "    if(periodLength==0 or tradingFee < BRANCHES.getMinTradingFee(branch) or tradingFee > POINTONETWOFIVE or EVENTS.getEventBranch(event) != branch or !INFO.getCreator(event) or makerFees < 0 or makerFees > ONEHALF):", 
            "        return(-1)", 
            "    if(expirationDate < block.timestamp):", 
            "        return(-2)", 
            "    if(forkPeriod && (futurePeriod == forkPeriod or futurePeriod == (forkPeriod+1))):", 
            "        return(-3)", 
            "    #scalars", 
            "    maxValue = EVENTS.getMaxValue(event)", 
            "    minValue = EVENTS.getMinValue(event)", 
            "    # is a valid scalar", 
            "    if((maxValue!=TWO || minValue !=ONE) && numOutcomes==2):", 
            "        # cumulativeScale is the range of a scalar", 
            "        cumulativeScale += maxValue - minValue", 
            "    if(cumulativeScale==0):", 
            "        cumulativeScale = ONE", 
            "", 
            "    # formation of marketID (hash)", 
            "    descriptionLength = INFO.getDescriptionLength(event)", 
            "    description = INFO.getDescription(event, outchars=descriptionLength)", 
            "    marketinfo = string(4*32 + descriptionLength)", 
            "    marketinfo[0] = futurePeriod", 
            "    marketinfo[1] = tradingFee", 
            "    marketinfo[2] = expirationDate", 
            "    marketinfo[3] = descriptionLength", 
            "    mcopy(marketinfo + 4*32, description, chars=descriptionLength)", 
            "    marketID = sha3(marketinfo, chars=len(marketinfo))", 
            "    # if it's already been created return 0", 
            "    if(INFO.getCreator(marketID)):", 
            "        return(-4)", 
            "    events = array(1)", 
            "    events[0] = event", 
            "    # initialize market and send money to pay for resolution", 
            "    if(CASH.sendFrom(branch, creationFee, msg.sender) && send(MARKETS, (msg.value-500000*tx.gasprice)) && INFO.setInfo(marketID, text(\"\"), msg.sender, creationFee) && BRANCHES.addMarketToBranch(branch, marketID) && MARKETS.initializeMarket(marketID, events, futurePeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumulativeScale, numOutcomes, extraInfo, msg.value-500000*tx.gasprice, creationFee, expirationDate)):", 
            "        CASH.initiateOwner(marketID)", 
            "        EVENTS.addMarket(event, marketID)", 
            "    else:", 
            "        throw()", 
            "    # add events to the appropriate reporting period", 
            "    if(EXPEVENTS.getEvent(branch, futurePeriod, EXPEVENTS.getEventIndex(futurePeriod, event))!=event):", 
            "        EXPEVENTS.addEvent(branch, futurePeriod, event, 500000*tx.gasprice)", 
            "        # cost for calculating num. of reports for an event", 
            "        if(!send(EXPEVENTS, 500000*tx.gasprice)):", 
            "            throw()", 
            "        if(!EVENTS.getBond(event)):", 
            "            # pay validity / indeterminate protection bond", 
            "            period = block.timestamp / TWENTYFOURHR", 
            "            if(!CASH.sendFrom(event, validity_bond, msg.sender)):", 
            "                throw()", 
            "            EVENTS.setBond(event, validity_bond)", 
            "            EVENTS.addPast24(period)", 
            "    log(type=marketCreated, msg.sender, marketID, tag1, branch, 500000*tx.gasprice, validity_bond, block.timestamp)", 
            "    return(marketID)", 
            "", 
            "# Updates a trading fee to be lower in a market", 
            "# Errors", 
            "    # -1: not the market creator", 
            "    # -2: invalid new trading fee", 
            "def updateTradingFee(branch, market, tradingFee, makerFees):", 
            "    refund()", 
            "    if(msg.sender != INFO.getCreator(market) || tx.origin != INFO.getCreator(market)):", 
            "        return(-1)", 
            "    oldFee = MARKETS.getTradingFee(market)", 
            "    oldCreationFee = POINTZEROSIX * BRANCHES.getBaseReporters(branch) * ONE / oldFee", 
            "    newCreationFee = POINTZEROSIX * BRANCHES.getBaseReporters(branch) * ONE / tradingFee", 
            "    if(tradingFee < BRANCHES.getMinTradingFee(branch) or tradingFee > oldFee or makerFees < 0 or makerFees > ONEHALF):", 
            "        return(-2)", 
            "    if(!CASH.sendFrom(branch, newCreationFee-oldCreationFee, msg.sender) || !MARKETS.setTradingFee(market, tradingFee) || !MARKETS.setMakerFees(market, makerFees)):", 
            "        throw()", 
            "    log(type=tradingFeeUpdated, msg.sender, branch, market, tradingFee, block.timestamp)", 
            "    return(1)", 
            "", 
            "# Anyone can post an \"Early Resolution Bond\"", 
            "# This bond is equal to 0.5 * Market_Fee * Market_Value", 
            "# This amount is the amount needed to pay the reporters in case this was frivolous.", 
            "# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'", 
            "    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)", 
            "# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration dateevent", 
            "# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.", 
            "def pushMarketForward(branch, market):", 
            "    refund()", 
            "    # can't do while forking", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    currentPeriod = block.timestamp / periodLength", 
            "    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1)):", 
            "        return(-1)", 
            "    # if market closed or already pushed forward, return 0", 
            "    if(MARKETS.getOneWinningOutcome(market, 0) or MARKETS.getPushedForward(market)):", 
            "        return(-2)", 
            "    if(CASH.sendFrom(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*ONE), msg.sender)==0):", 
            "        return(-3)", 
            "    event = MARKETS.getMarketEvent(market, 0)", 
            "    expiration = EVENTS.getExpiration(event)", 
            "    if(EVENTS.getRejectedPeriod(event) || expiration!=EVENTS.getOriginalExpiration(event) || EVENTS.getOutcome(event) || BACKSTOPS.getRoundTwo(event) || expiration/periodLength==block.timestamp/periodLength):", 
            "            return(-4)", 
            "    # push into next vote period", 
            "    period = block.timestamp/periodLength", 
            "    # figure out what's going on with subsidy system here todo", 
            "    EXPEVENTS.addEvent(branch, period, event, 0)", 
            "    # set event expiration date to be after the current reporting period ends", 
            "    EVENTS.setExpiration(event, block.timestamp)", 
            "    MARKETS.setTradingPeriod(market, period)", 
            "    MARKETS.setPushedForward(market, 1, msg.sender)", 
            "    EVENTS.setEventPushedUp(event, 1)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }
                ], 
                "name": "createEvent(int256,bytes,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }
                ], 
                "name": "createMarket(int256,int256,int256,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }
                ], 
                "name": "createSingleEventMarket(int256,bytes,int256,int256,int256,int256,bytes,int256,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "pushMarketForward(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }
                ], 
                "name": "updateTradingFee(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "topic", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "marketCreationFee", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "eventBond", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "marketCreated(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "tradingFeeUpdated(int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern createMarket: [createEvent:[int256,bytes,int256,int256,int256,int256,bytes]:int256, createMarket:[int256,int256,int256,int256,int256,int256,int256,bytes]:int256, createSingleEventMarket:[int256,bytes,int256,int256,int256,int256,bytes,int256,int256,int256,int256,int256,bytes]:int256, pushMarketForward:[int256,int256]:int256, test_callstack:[]:int256, updateTradingFee:[int256,int256,int256,int256]:int256]"
    }, 
    "eventResolution": {
        "address": "0x3f3276849a878a176b2f02dd48a483e8182a49e4", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "inset('refund.se')", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "## helper function to close an event for resolution", 
            "macro closeOut($event, $market, $branch, $votingPeriodEvent, $fxpOutcome, $periodLength, $ethical, $scalarorcat, $mode, $ethicOutcome):", 
            "    # In the $event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and $market remains with old expiration date", 
            "    # UI needs to call penalizeWrong for ones that are pushed back in both pushed back period and regular period with actual reporting", 
            "    $indeterminate = ONEHALF*3", 
            "    if(($fxpOutcome == $indeterminate or $mode==ONEHALF) && EVENTS.getEventPushedUp($event)):", 
            "        if(MARKETS.getPushedForward($market)):", 
            "            CASH.addCash($branch, MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "            CASH.subtractCash($market, MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "        MARKETS.setTradingPeriod($market, MARKETS.getOriginalTradingPeriod($market))", 
            "        MARKETS.setPushedForward($market, 0, msg.sender)", 
            "        EXPEVENTS.setNumReportsEvent($branch, $votingPeriodEvent, $event, 0)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome($event, 0)", 
            "        EVENTS.setmode($event, 0)", 
            "        EVENTS.setEthics($event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome($event, 0)", 
            "        EVENTS.setEventPushedUp($event, 0)", 
            "        # need to store which period it was \"rejected\" in", 
            "        EVENTS.setRejected($event, EVENTS.getExpiration($event)/$periodLength)", 
            "        #set $event expiration to be the old date", 
            "        EVENTS.setExpiration($event, EVENTS.getOriginalExpiration($event))", 
            "        -6", 
            "    elif(($fxpOutcome==$indeterminate or $mode==ONEHALF) || !$ethical):", 
            "        # give $event bond money to reporters", 
            "        CASH.subtractCash($event, EVENTS.getBond($event))", 
            "        CASH.addCash($branch, EVENTS.getBond($event))", 
            "        # not $ethical is same as .5 outcome", 
            "        if($scalarorcat):", 
            "            # the mode is used to compare for reporting accuracy. so still the same as the reported uncaught outcome/mode, but resolving the market as .5 right in the middle of the range so payouts are done right for an unethical [or indeterminate] market", 
            "            EVENTS.setOutcome($event, $ethicOutcome)", 
            "        else:", 
            "            EVENTS.setOutcome($event, $indeterminate)", 
            "        1", 
            "    else:", 
            "        # return bond as a normal event resolution", 
            "        CASH.subtractCash($event, EVENTS.getBond($event))", 
            "        CASH.addCash(INFO.getCreator($event), EVENTS.getBond($event))", 
            "        if(MARKETS.getPushedForward($market)):", 
            "            CASH.addCash(MARKETS.getBondsMan($market), MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "            CASH.subtractCash($market, MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "        if(EVENTS.getEventPushedUp($event)):", 
            "            # delete old $event from future events exp", 
            "            $period = EVENTS.getOriginalExpiration($event)/$periodLength", 
            "            EXPEVENTS.removeEvent($branch, $period)", 
            "            EXPEVENTS.deleteEvent($branch, $period, $event)", 
            "            EVENTS.setOriginalExpiration($event, EVENTS.getExpiration($event))", 
            "        1", 
            "", 
            "# Resolves a binary market", 
            "def resolveBinary(event, market, branch, votingPeriodEvent):", 
            "    refund()", 
            "    fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    # outcome is set to the binned version of the raw reported outcome", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    # ethics is set to the binned version of the raw ethicality outcome", 
            "    EVENTS.setEthics(event, ethical)", 
            "    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 0, 0, 0)", 
            "    return(val)", 
            "", 
            "# Resolves a categorical market", 
            "def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent):", 
            "    refund()", 
            "    mode = EVENTS.getUncaughtOutcome(event)", 
            "    EVENTS.setmode(event, mode)", 
            "    fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min", 
            "    if(categorical(event)):", 
            "        fxpOutcome = round(fxpOutcome)", 
            "    # outcome is set to the mode of the reported outcomes", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    # ethics is set to the binned version of the raw ethicality outcome", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    ethicOutcome = ONEHALF * (scaled_max - scaled_min)/ONE + scaled_min", 
            "    EVENTS.setEthics(event, ethical)", 
            "    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 1, mode, ethicOutcome)", 
            "    return(val)", 
            "", 
            "macro round($x):", 
            "    if(($x + ONEHALF) / ONE != ($x / ONE)):", 
            "        ($x + ONEHALF) / ONE * ONE", 
            "    else:", 
            "        $x / ONE * ONE", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event) > 2)", 
            "", 
            "# Determines the \"winning outcomes\" for a given market", 
            "# Easiest to give examples:", 
            "    # 1D Markets:", 
            "        # Binary or Categorical will have 1 winning outcome [1 or 2 for binary, 1 thru numOutcomes for categorical is the poss. value for the winning outcome]", 
            "def determineWinningOutcomes(event):", 
            "    refund()", 
            "    winningOutcomes = array(8)", 
            "    fxpOutcome = EVENTS.getOutcome(event)", 
            "    outcome = fxpOutcome/ONE", 
            "    if(n==0):", 
            "        #scalar or .5", 
            "        if(scalar(event) || fxpOutcome==3*ONEHALF):", 
            "            winningOutcomes[0] = 1", 
            "            winningOutcomes[1] = 2", 
            "        # anything besides scalar or .5", 
            "        else:", 
            "            winningOutcomes[0] += outcome", 
            "    return(winningOutcomes: arr)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "determineWinningOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveBinary(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "scaled_min", 
                        "type": "int256"
                    }, 
                    {
                        "name": "scaled_max", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveCategoricalOrScalar(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern eventResolution: [determineWinningOutcomes:[int256]:int256[], resolveBinary:[int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "events": {
        "address": "0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "inset('refund.se')", 
            "", 
            "# Keeps track of data about events in augur", 
            "# Events' index is the eventID", 
            "# so max-min/numOutcomes is interval between outcomes (useful for ui for categoricals, e.g. 1 is >50, 2 is >100, etc.)", 
            "# markets keeps track of the markets associated with an event", 
            "# threshold is the min \"random\" sha threshold for reporting on an event used in the scenario where no one reports on an event", 
            "# mode is the mode reported value for a given event [only on categorical / scalar events]", 
            "# uncaughtOutcome is the average reported value for a binary event", 
            "# ethical is the ethicality for a given event", 
            "# originalExp is original expiry date in the case an event was pushed back and the expiration date gets changed - both are in epoch time", 
            "# pushedUp states that an event was pushed forward to attempt early resolution", 
            "# rejected states that a pushed forward market's event [so one that attempted to resolve before it was expired] got rejected and shouldn't have actually been pushed forward", 
            "    # rejectedPeriod is the period such an event was pushed forward to and failed to be resolved in", 
            "# bond is the indeterminate bond that's taken away if an event is reported on as indeterminate", 
            "# forked is whether an event was the event a branch was forked over", 
            "# forkOver is whether the event that was forked over is resolved", 
            "# forkOutcome is the outcome of an event that was forked over", 
            "# forkEthicality is the ethicality of an event that was forked over", 
            "# resolutionSource is a string with the recommended source for resolving a market", 
            "data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength, pushedUp)", 
            "", 
            "# Keeps track of number of events created in the past 24 hours", 
            "data past24Hours[]", 
            "", 
            "def getEventPushedUp(event):", 
            "    return(self.Events[event].pushedUp)", 
            "", 
            "def setEventPushedUp(event, val):", 
            "    self.Events[event].pushedUp = val", 
            "    return(1)", 
            "", 
            "def getForkOutcome(event):", 
            "    return(self.Events[event].forkOutcome)", 
            "", 
            "def setForkOutcome(event, value):", 
            "    self.Events[event].forkOutcome = value", 
            "    return(1)", 
            "", 
            "def getForkEthicality(event):", 
            "    return(self.Events[event].forkEthicality)", 
            "", 
            "def setForkEthicality(event, value):", 
            "    self.Events[event].forkEthicality = value", 
            "    return(1)", 
            "", 
            "def getForked(event):", 
            "    return(self.Events[event].forked)", 
            "", 
            "def setForked(event):", 
            "    self.Events[event].forked = 1", 
            "    return(1)", 
            "", 
            "def setForkDone(event):", 
            "    self.Events[event].forkOver = 1", 
            "    return(1)", 
            "", 
            "def getForkedDone(event):", 
            "    return(self.Events[event].forkOver)", 
            "", 
            "def getEventInfo(event):", 
            "    refund()", 
            "    eventinfo = array(7)", 
            "    eventinfo[0] = self.Events[event].branch", 
            "    eventinfo[1] = self.Events[event].expirationDate", 
            "    eventinfo[2] = self.Events[event].outcome", 
            "    eventinfo[3] = self.Events[event].minValue", 
            "    eventinfo[4] = self.Events[event].maxValue", 
            "    eventinfo[5] = self.Events[event].numOutcomes", 
            "    eventinfo[6] = self.Events[event].bond", 
            "    return(eventinfo: arr)", 
            "", 
            "def getResolutionLength(event):", 
            "    return(self.Events[event].resolutionSourceLength)", 
            "", 
            "def getResolution(event):", 
            "    refund()", 
            "    length=self.Events[event].resolutionSourceLength", 
            "    return(load(self.Events[event].resolutionSource[0], chars=length): str)", 
            "", 
            "def getPast24(period):", 
            "    refund()", 
            "    return(self.past24Hours[period])", 
            "", 
            "def addPast24(period):", 
            "    refund()", 
            "    self.past24Hours[period] += 1", 
            "    return(1)", 
            "", 
            "def getEventBranch(event):", 
            "    refund()", 
            "    return(self.Events[event].branch)", 
            "", 
            "def getExpiration(event):", 
            "    refund()", 
            "    return(self.Events[event].expirationDate)", 
            "", 
            "def getOriginalExpiration(event):", 
            "    refund()", 
            "    return(self.Events[event].originalExp)", 
            "", 
            "def setOriginalExpiration(event, date):", 
            "    self.Events[event].originalExp = date", 
            "    return(1)", 
            "", 
            "def setExpiration(event, date):", 
            "    refund()", 
            "    self.Events[event].expirationDate = date", 
            "    return(1)", 
            "", 
            "def setBranch(event, branch):", 
            "    self.Events[event].branch = branch", 
            "    return(1)", 
            "", 
            "def getOutcome(event):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "    return(self.Events[event].outcome)", 
            "", 
            "def getEthics(event):", 
            "    refund()", 
            "    return(self.Events[event].ethical)", 
            "", 
            "def setEthics(event, ethicality):", 
            "    refund()", 
            "    self.Events[event].ethical = ethicality", 
            "    return(ethicality)", 
            "", 
            "def getEthical(event):", 
            "    refund()", 
            "    return(self.Events[event].ethical)", 
            "", 
            "def getMinValue(event):", 
            "    refund()", 
            "    return(self.Events[event].minValue)", 
            "", 
            "def getMaxValue(event):", 
            "    refund()", 
            "    return(self.Events[event].maxValue)", 
            "", 
            "def getNumOutcomes(event):", 
            "    refund()", 
            "    return(self.Events[event].numOutcomes)", 
            "", 
            "def setUncaughtOutcome(event, outcome):", 
            "    refund()", 
            "    self.Events[event].uncaughtOutcome = outcome", 
            "    return(1)", 
            "", 
            "def getUncaughtOutcome(event):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "    return(self.Events[event].uncaughtOutcome)", 
            "", 
            "def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):", 
            "    refund()", 
            "    # check that msg.sender is one of our function contracts", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    if(self.Events[ID].expirationDate==0):", 
            "        self.Events[ID].branch = branch", 
            "        self.Events[ID].expirationDate = expirationDate", 
            "        self.Events[ID].originalExp = expirationDate", 
            "        self.Events[ID].minValue = minValue", 
            "        self.Events[ID].maxValue = maxValue", 
            "        self.Events[ID].numOutcomes = numOutcomes", 
            "        resolutionSourceLength = len(resolution)", 
            "        self.Events[ID].resolutionSourceLength = resolutionSourceLength", 
            "        save(self.Events[ID].resolutionSource[0], resolution, chars=resolutionSourceLength)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def setBond(event, bond):", 
            "    refund()", 
            "    self.Events[event].bond = bond", 
            "    return(1)", 
            "", 
            "def addMarket(event, marketID):", 
            "    refund()", 
            "    self.Events[event].markets[self.Events[event].numMarkets] = marketID", 
            "    self.Events[event].numMarkets += 1", 
            "    return(1)", 
            "", 
            "def getBranch(event):", 
            "    return(self.Events[event].branch)", 
            "", 
            "def getBond(event):", 
            "    refund()", 
            "    return(self.Events[event].bond)", 
            "", 
            "def getMarkets(event):", 
            "    refund()", 
            "    i = 0", 
            "    markets = array(self.Events[event].numMarkets)", 
            "    while i < self.Events[event].numMarkets:", 
            "        markets[i] = self.Events[event].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getMarket(event, marketIndex):", 
            "    refund()", 
            "    return(self.Events[event].markets[marketIndex])", 
            "", 
            "def getNumMarkets(event):", 
            "    refund()", 
            "    return(self.Events[event].numMarkets)", 
            "", 
            "def setOutcome(ID, outcome):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.Events[ID].outcome = outcome", 
            "    return(1)", 
            "", 
            "def getReportingThreshold(event):", 
            "    refund()", 
            "    return(self.Events[event].threshold)", 
            "", 
            "def setThreshold(event, threshold):", 
            "    # do whitelist", 
            "    self.Events[event].threshold = threshold", 
            "    return(1)", 
            "", 
            "def getmode(event):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "    return(self.Events[event].mode)", 
            "", 
            "def setmode(event, mode):", 
            "    refund()", 
            "    self.Events[event].mode = mode", 
            "    return(1)", 
            "", 
            "def setRejected(event, period):", 
            "    refund()", 
            "    self.Events[event].rejected = 1", 
            "    self.Events[event].rejectedPeriod = period", 
            "    return(1)", 
            "", 
            "def getRejected(event):", 
            "    refund()", 
            "    return(self.Events[event].rejected)", 
            "", 
            "def getRejectedPeriod(event):", 
            "    refund()", 
            "    return(self.Events[event].rejectedPeriod)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "addPast24(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBond(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthical(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthics(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventPushedUp(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkEthicality(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForked(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkedDone(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMaxValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getPast24(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejected(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getResolution(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getResolutionLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getUncaughtOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getmode(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expirationDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }
                ], 
                "name": "initializeEvent(int256,int256,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bond", 
                        "type": "int256"
                    }
                ], 
                "name": "setBond(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethicality", 
                        "type": "int256"
                    }
                ], 
                "name": "setEthics(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "val", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventPushedUp(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "date", 
                        "type": "int256"
                    }
                ], 
                "name": "setExpiration(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkDone(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkEthicality(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setForked(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "date", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalExpiration(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setRejected(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "threshold", 
                        "type": "int256"
                    }
                ], 
                "name": "setThreshold(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setUncaughtOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "mode", 
                        "type": "int256"
                    }
                ], 
                "name": "setmode(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "expiringEvents": {
        "address": "0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
        "code": [
            "# todo move extern stuff into a new contract", 
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have receive a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "inset('refund.se')", 
            "", 
            "# [branchID][votingPeriod]", 
            "# reporthash is [reporterID][event] = hash", 
            "# subsidy is money for paying back a user for calculating the targeted num of reports for an event", 
            "data EventIDToIndex[][]", 
            "data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], encryptedReport[][](report, salt), shareValue, subsidy[], roundTwoNumEvents)", 
            "", 
            "# numReportsEvent is number of reports on an event, expected is how many have been committed for an event", 
            "# numReportsActual is the amount of reports a user has submitted in a period", 
            "# lesserReportNum is the number of reports an event should have [the lesser of how many it can afford from fees and how many it should have due to outstanding share value]", 
            "# periodRepConstant is", 
            "data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsActual[][], repEvent[][], lesserReportNum[][], periodRepConstant[][], reportersPaidSoFarForEvent[])", 
            "", 
            "# branch, period as params", 
            "data numReqEvents[][]", 
            "data requiredEvents[]", 
            "data mode_items[][](report_value[], current_mode, current_mode_items)", 
            "", 
            "def getEncryptedReport(branch, expDateIndex, reporter, event):", 
            "    refund()", 
            "    return([self.EventsExpDates[branch][expDateIndex].encryptedReport[reporter][event].report, self.EventsExpDates[branch][expDateIndex].encryptedReport[reporter][event].salt, self.branches[branch].ethics[expDateIndex][reporter].event[event]]: arr)", 
            "", 
            "# both the report and the salt should be encrypted", 
            "def setEncryptedReport(branch, expDateIndex, reporter, report, salt, ethics, event):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.EventsExpDates[branch][expDateIndex].encryptedReport[reporter][event].report = report", 
            "    self.EventsExpDates[branch][expDateIndex].encryptedReport[reporter][event].salt = salt", 
            "    self.branches[branch].ethics[expDateIndex][reporter].event[event] = ethics", 
            "    return(1)", 
            "", 
            "def getReportersPaidSoFar(branch, event):", 
            "    return(self.branches[branch].reportersPaidSoFarForEvent[event])", 
            "", 
            "def addReportersPaidSoFar(branch, event):", 
            "    self.branches[branch].reportersPaidSoFarForEvent[event] += 1", 
            "    return(1)", 
            "", 
            "def refundCost(to, value):", 
            "    send(to, value)", 
            "    return(1)", 
            "", 
            "def getSubsidy(branch, period, event):", 
            "    return(self.EventsExpDates[branch][period].subsidy[event])", 
            "", 
            "def getPeriodRepConstant(branch, votePeriod, sender):", 
            "    return(self.branches[branch].periodRepConstant[votePeriod][sender])", 
            "", 
            "def setPeriodRepConstant(branch, votePeriod, sender, value):", 
            "    self.branches[branch].periodRepConstant[votePeriod][sender] = value", 
            "    return(1)", 
            "", 
            "def getLesserReportNum(branch, period, event):", 
            "    return(self.branches[branch].lesserReportNum[period][event])", 
            "", 
            "def getCurrentModeItems(period, event):", 
            "    return(self.mode_items[period][event].current_mode_items)", 
            "", 
            "def getCurrentMode(period, event):", 
            "    return(self.mode_items[period][event].current_mode)", 
            "", 
            "# returns weight of a report value for the mode", 
            "def getWeightOfReport(period, event, report):", 
            "    return(self.mode_items[period][event].report_value[report])", 
            "", 
            "def getRepEvent(branch, votePeriod, event):", 
            "    return(self.branches[branch].repEvent[votePeriod][event])", 
            "", 
            "def getEthicReport(branch, period, event, sender):", 
            "    return(self.branches[branch].ethics[period][sender].event[event])", 
            "", 
            "def getNumReportsEvent(branch, votePeriod, eventID):", 
            "    return(self.branches[branch].numReportsEvent[votePeriod][eventID])", 
            "", 
            "def getReport(branch, period, event, sender):", 
            "    #if(whitelist):", 
            "    return(self.branches[branch].report[period][sender].event[event])", 
            "", 
            "def getBeforeRep(branch, period, sender):", 
            "    return(self.branches[branch].beforeRep[period][sender])", 
            "", 
            "def getAfterRep(branch, period, sender):", 
            "    return(self.branches[branch].afterRep[period][sender])", 
            "", 
            "def getPeriodDormantRep(branch, period, sender):", 
            "    return(self.branches[branch].periodDormantRep[period][sender])", 
            "", 
            "def getNumReportsActual(branch, votePeriod, sender):", 
            "    return(self.branches[branch].numReportsActual[sender][votePeriod])", 
            "", 
            "def getNumRoundTwo(branch, period):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][period].roundTwoNumEvents)", 
            "", 
            "def addRoundTwo(branch, period):", 
            "    refund()", 
            "    self.EventsExpDates[branch][period].roundTwoNumEvents += 1", 
            "    return(1)", 
            "", 
            "def getRequired(event):", 
            "    return(self.requiredEvents[event])", 
            "", 
            "def getNumRequired(branch, period):", 
            "    return(self.numReqEvents[branch][period])", 
            "", 
            "# Return 0 means already required", 
            "def setEventRequired(branch, period, event):", 
            "    if(self.requiredEvents[event]==0):", 
            "        self.requiredEvents[event] = 1", 
            "        self.numReqEvents[branch][period] += 1", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# With this function you can get the eventIDs and report on outcomes", 
            "# @return all events in a branch and expiration period", 
            "def getEvents(branch, expDateIndex):", 
            "    refund()", 
            "    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "    events = array(numEvents)", 
            "    i = 0", 
            "    while i < numEvents:", 
            "        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getEventsRange(branch, expDateIndex, start, end):", 
            "    refund()", 
            "    numEvents = end-start", 
            "    events = array(numEvents)", 
            "    i = start", 
            "    index = 0", 
            "    while i < end:", 
            "        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        index += 1", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getEventIndex(period, eventID):", 
            "    refund()", 
            "    return(self.EventIDToIndex[period][eventID])", 
            "", 
            "# we should probably make this bonded too", 
            "# -1: voting not started", 
            "def setNumEventsToReportOn(branch):", 
            "    refund()", 
            "    # after voting has started", 
            "    expDateIndex = BRANCHES.getVotePeriod(branch)", 
            "    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*BRANCHES.getBaseReporters(branch)", 
            "    return(1)", 
            "", 
            "def getNumEventsToReportOn(branch, expDateIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)", 
            "", 
            "def getShareValue(branch, expIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expIndex].shareValue)", 
            "", 
            "def getNumberEvents(branch, expDateIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].numberEvents)", 
            "", 
            "def getEvent(branch, expDateIndex, eventIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])", 
            "", 
            "def getReportHash(branch, expDateIndex, reporter, event):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addEvent(branch, futurePeriod, eventID, subsidy):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID", 
            "    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents", 
            "    self.EventsExpDates[branch][futurePeriod].numberEvents += 1", 
            "    self.EventsExpDates[branch][futurePeriod].subsidy[eventID] += subsidy", 
            "    return(1)", 
            "", 
            "def deleteEvent(branch, period, event):", 
            "    i = self.EventIDToIndex[period][event]", 
            "    self.EventsExpDates[branch][period].events[i] = 0", 
            "    self.EventIDToIndex[period][event] = 0", 
            "    return(1)", 
            "", 
            "def removeEvent(branch, period):", 
            "    refund()", 
            "    self.EventsExpDates[branch][period].numberRemoved += 1", 
            "    return(1)", 
            "", 
            "def getNumRemoved(branch, period):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][period].numberRemoved)", 
            "", 
            "def adjustPeriodShareValueOutstanding(branch, expIndex, amount):", 
            "    refund()", 
            "    self.EventsExpDates[branch][expIndex].shareValue += amount", 
            "    return(1)", 
            "", 
            "def setReportHash(branch, expDateIndex, reporter, reportHash, event):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash", 
            "    return(1)", 
            "", 
            "# called in case an event doesn't get reported on at all in a period", 
            "def moveEvent(branch, event):", 
            "    period = EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch)", 
            "    if(BRANCHES.getVotePeriod(branch) > period && !EVENTS.getUncaughtOutcome(event)):", 
            "        # add to next expiration period", 
            "        self.addEvent(branch, block.timestamp/BRANCHES.getPeriodLength(branch), event)", 
            "        EVENTS.setExpiration(event, block.timestamp)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def addToWeightOfReport(period, event, report, amount):", 
            "    self.mode_items[period][event].report_value[report] += amount", 
            "    return(1)", 
            "", 
            "def setCurrentMode(period, event, mode):", 
            "    self.mode_items[period][event].current_mode = mode", 
            "    return(1)", 
            "", 
            "# basically setting current mode's weight", 
            "def setCurrentModeItems(period, event, modeReport):", 
            "    self.mode_items[period][event].current_mode_items = self.mode_items[period][event].report_value[modeReport]", 
            "    return(1)", 
            "", 
            "def addRepEvent(branch, votePeriod, event, amount):", 
            "    self.branches[branch].repEvent[votePeriod][event] += amount", 
            "    return(1)", 
            "", 
            "def setEthicReport(branch, period, event, ethics, sender):", 
            "    self.branches[branch].ethics[period][sender].event[event] = ethics", 
            "    return(1)", 
            "", 
            "def setNumReportsEvent(branch, votePeriod, eventID, num):", 
            "    self.branches[branch].numReportsEvent[votePeriod][eventID] = num", 
            "    return(1)", 
            "", 
            "def addReportToEvent(branch, votePeriod, eventID, sender):", 
            "    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1", 
            "    self.branches[branch].numReportsActual[sender][votePeriod] += 1", 
            "    return(1)", 
            "", 
            "def setReport(branch, period, event, report, sender):", 
            "    self.branches[branch].report[period][sender].event[event] = report", 
            "    return(1)", 
            "", 
            "def setBeforeRep(branch, period, rep, sender):", 
            "    self.branches[branch].beforeRep[period][sender] = rep", 
            "    return(rep)", 
            "", 
            "def setAfterRep(branch, period, rep, sender):", 
            "    self.branches[branch].afterRep[period][sender] = rep", 
            "    return(rep)", 
            "", 
            "def setPeriodDormantRep(branch, period, rep, sender):", 
            "    self.branches[branch].periodDormantRep[period][sender] = rep", 
            "    return(rep)", 
            "", 
            "def setLesserReportNum(branch, period, event, num):", 
            "    self.branches[branch].lesserReportNum[period][event] = num", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "futurePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "subsidy", 
                        "type": "int256"
                    }
                ], 
                "name": "addEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addRepEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "addReportToEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "addReportersPaidSoFar(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "addRoundTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addToWeightOfReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "adjustPeriodShareValueOutstanding(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "deleteEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getAfterRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getBeforeRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentMode(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentModeItems(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEncryptedReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthicReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "start", 
                        "type": "int256"
                    }, 
                    {
                        "name": "end", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventsRange(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getLesserReportNum(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumRemoved(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsActual(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumRequired(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumRoundTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodRepConstant(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportersPaidSoFar(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRequired(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getShareValue(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getSubsidy(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }
                ], 
                "name": "getWeightOfReport(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "moveEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "refundCost(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "removeEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setAfterRep(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setBeforeRep(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "mode", 
                        "type": "int256"
                    }
                ], 
                "name": "setCurrentMode(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "modeReport", 
                        "type": "int256"
                    }
                ], 
                "name": "setCurrentModeItems(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEncryptedReport(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setEthicReport(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventRequired(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setLesserReportNum(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumEventsToReportOn(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setPeriodDormantRep(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "setPeriodRepConstant(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setReport(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "faucets": {
        "address": "0xc21cfa6688dbfd2eca2548d894aa55fd0bbf1c7e", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation OU", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact jack@augur.net or joey@augur.net.", 
            "", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "inset('refund.se')", 
            "", 
            "macro POINTSEVEN: 700000000000000000", 
            "macro POINTZEROONE: 10000000000000000", 
            "", 
            "event fundedAccount(branch: indexed, sender: indexed, cashBalance, repBalance, timestamp)", 
            "", 
            "# Error -1: Hey, you're not broke!", 
            "def cashFaucet():", 
            "    refund()", 
            "    if CASH.balance(msg.sender) > 5*ONE:", 
            "        return(-1)", 
            "    CASH.setCash(msg.sender, 10000*ONE)", 
            "    return(1)", 
            "", 
            "def reputationFaucet(branch):", 
            "    refund()", 
            "    if REPORTING.repIDToIndex(branch, tx.origin) != 0 or REPORTING.getReporterID(branch, 0) == tx.origin:", 
            "        index = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    else:", 
            "        index = REPORTING.getNumberReporters(branch)", 
            "        REPORTING.addReporter(branch, tx.origin, 0, 0, 0)", 
            "    REPORTING.setRep(branch, index, 47*ONE)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    if block.timestamp % periodLength <= periodLength / 2:", 
            "        penalizedUpTo = BRANCHES.getVotePeriod(branch) - 1", 
            "    else:", 
            "        penalizedUpTo = BRANCHES.getVotePeriod(branch)", 
            "    CONSENSUS.setPenalizedUpTo(branch, tx.origin, penalizedUpTo)", 
            "    CONSENSUS.setFeesCollected(branch, tx.origin, penalizedUpTo)", 
            "    return(1)", 
            "", 
            "def fundNewAccount(branch):", 
            "    CASH.send(self, 0)", 
            "    self.reputationFaucet(branch)", 
            "    CASH.setCash(msg.sender, 10000*ONE)", 
            "    log(type=fundedAccount, branch, msg.sender, 10000*ONE, 47*ONE, block.timestamp)", 
            "    return(1)", 
            "", 
            "# Used to claim rep on a fork or on a new branch", 
            "# Returns 1 if successful, 0 if already claimed", 
            "# Error:", 
            "    # -1: parent isn't the actual parent", 
            "def claimInitialRep(parent, branch):", 
            "    refund()", 
            "    if(BRANCHES.getParent(branch)!=parent):", 
            "        return(-1)", 
            "    # have 1 month to claim", 
            "    if(REPORTING.repIDToIndex(branch, msg.sender)==0 && block.timestamp < (BRANCHES.getCreationDate(branch) + TWENTYFOURHR*30)):", 
            "        parentPeriod = BRANCHES.getParentPeriod(branch)", 
            "        forkPeriod = BRANCHES.getForkPeriod(parent)", 
            "        fork = REPORTING.getFork(parent)", 
            "        forkEvent = BRANCHES.getEventForkedOver(parent)", 
            "        report = EXPEVENTS.getReport(parent, forkPeriod, forkEvent, msg.sender)", 
            "        outcome = EVENTS.getUncaughtOutcome(forkEvent)", 
            "        if(binary(forkEvent)):", 
            "            outcome = catch(outcome)", 
            "        ethical = ethic_catch(EVENTS.getEthical(forkEvent))", 
            "        ethicReport = EXPEVENTS.getEthicReport(parent, forkPeriod, forkEvent, msg.sender)", 
            "        rep = EXPEVENTS.getBeforeRep(parent, parentPeriod, msg.sender)", 
            "        repDecrease = 0", 
            "        # if forked and (reported with original consensus or didn't report or (reported with original ethicality and forked over ethicality))", 
            "        if(fork && ((report >= (outcome-POINTZEROONE) && report <= (outcome+POINTZEROONE)) || report==0 || (BACKSTOPS.getForkedOverEthicality(forkEvent) && ethical==ethicReport))):", 
            "            # take away 30% of rep from liars and those who didn't report", 
            "            repDecrease = rep - rep*POINTSEVEN/ONE", 
            "            rep = rep - repDecrease", 
            "            amountLeftToPayBonder = BACKSTOPS.getBondAmount(forkEvent) - BACKSTOPS.getForkBondPaid(forkEvent)", 
            "            if(repDecrease < amountLeftToPayBonder):", 
            "                # send all the rep to the fork bond poster", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getForkBondPoster(forkEvent)), repDecrease)", 
            "            else:", 
            "                # send amountLeftToPayBonder [if positive] to the fork bond poster", 
            "                if(amountLeftToPayBonder > 0):", 
            "                    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getForkBondPoster(forkEvent)), amountLeftToPayBonder)", 
            "                    # send the rest to the new branch's redistribution pool", 
            "                    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), (repDecrease - amountLeftToPayBonder))", 
            "                else:", 
            "                    # send to new branch's redistribution pool", 
            "                    REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), repDecrease)", 
            "        if(fork):", 
            "            CONSENSUS.setPenalizedUpTo(branch, msg.sender, forkPeriod)", 
            "        else:", 
            "            CONSENSUS.setPenalizedUpTo(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "        # todo this doesn't work if hasn't reported last period", 
            "        dormantRep = EXPEVENTS.getPeriodDormantRep(parent, BRANCHES.getParentPeriod(branch), msg.sender)", 
            "        REPORTING.addReporter(branch, msg.sender, rep, dormantRep, repDecrease)", 
            "        return(1)", 
            "    else:", 
            "        # already claimed or too late", 
            "        return(0)", 
            "", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [], 
                "name": "cashFaucet()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "claimInitialRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "fundNewAccount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "reputationFaucet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cashBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "repBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "fundedAccount(int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern faucets: [cashFaucet:[]:int256, claimInitialRep:[int256,int256]:int256, fundNewAccount:[int256]:int256, reputationFaucet:[int256]:int256, test_callstack:[]:int256]"
    }, 
    "forkPenalize": {
        "address": "0xd15a6cfc462ae76b9ec590cab8b34bfa8e1302d7", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "", 
            "inset('refund.se')", 
            "", 
            "", 
            "# Penalizes a reporter for reporting wrongly on a forked event / backstop 2", 
            "# Notes:", 
            "    # essentially penalizeWrong for backstop 2 [where everyone reports on a forked event on the new branch]", 
            "    # only called on the fork not the parent, normal penalization except the outcome values are forkOutcome and forkEthicality as opposed to anything else", 
            "    # some rep from this goes to bond poster", 
            "    # branch is the fork, not the parent", 
            "    # fork event needs to be resolved first before this can be called", 
            "# Errors:", 
            "    #  0: not enough rep to report/penalize", 
            "    # -2: already past first half of new period and needed to penalize before then", 
            "    # -4: fork event isn't resolved yet", 
            "    # -5: already done for all events in this period", 
            "    # -6: needed to collect fees last period which sets the before/after rep", 
            "def penalizeOnForkedEvent(branch, event):", 
            "    refund()", 
            "    repBalance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    newRep = 0", 
            "    newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)", 
            "    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)", 
            "    if(repBalance < ONE):", 
            "        return(0)", 
            "    forkOutcome = EVENTS.getForkOutcome(event)", 
            "    outcome = catch(forkOutcome)", 
            "    if(scalar(event) or categorical(event)):", 
            "        outcome = forkOutcome", 
            "    p = self.proportionCorrectForkEvent(event)", 
            "    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)", 
            "    ethics = EXPEVENTS.getEthicReport(branch, lastPeriod, event, msg.sender)", 
            "    bond = BACKSTOPS.getBondAmount(event)", 
            "    if(CONSENSUS.getPenalizedUpTo(branch, msg.sender)==lastPeriod):", 
            "        return(-5)", 
            "    if(!CONSENSUS.getFeesCollected(branch, msg.sender, lastPeriod)):", 
            "        return(-6)", 
            "    # means event / fork isn't resolved", 
            "    if(EVENTS.getForkedDone(event)==0):", 
            "        return(-4)", 
            "    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period", 
            "    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):", 
            "        return(-2)", 
            "    numReportedOn = EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)", 
            "    # penalization on a forked event", 
            "    # if didn't report [reportValue of 0] then it's a bad report here", 
            "    # Do (for each user) based on forking report and final outcome", 
            "    if(!CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event)):", 
            "        if(outcome!=0):", 
            "            # wrong", 
            "            #184467440737095520 == 0.01 in fxp", 
            "            if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):", 
            "                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                    diff = reportValue - outcome", 
            "                    p = -(abs(diff)/2) + ONE", 
            "                newRep = oldRep*(2*p - ONE)/ONE", 
            "            # right", 
            "            else:", 
            "                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                    diff = reportValue - outcome", 
            "                    p = -(abs(diff)/2) + ONE", 
            "                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE", 
            "            # (1-k) * old rep + k * new rep where k = 1 / (number of events you reported on last period) for forking", 
            "            # use .10 as a max penalty per fork event", 
            "            if(numReportedOn<10):", 
            "                repChange = oldRep * (ONE - ONE/10)/ONE + newRep*(ONE/10)/ONE - oldRep", 
            "            else:", 
            "                repChange = oldRep * (ONE - ONE/numReportedOn)/ONE + newRep*(ONE/numReportedOn)/ONE - oldRep", 
            "            newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange", 
            "            EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "            # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively", 
            "            if(ethics != ethic_catch(EVENTS.getEthical(event)) && repChange >=0):", 
            "                repChange = -POINTTWO*repBalance / ONE", 
            "            if(repBalance + repChange <= 0):", 
            "                repChange = -1*repBalance", 
            "            if(BACKSTOPS.getForkBondPaid(event) < BACKSTOPS.getBondAmount(event)*2 && repChange < 0):", 
            "                # done instead of sending to redistrib. pool", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), repChange)", 
            "                # sends that rep to the bonded challenger", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getForkBondPoster(event)), -repChange)", 
            "                BACKSTOPS.adjForkBondPaid(event, -1*repChange)", 
            "        CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)", 
            "        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)", 
            "    # once penalized for all events actually get rid of net rep lost", 
            "    if(numReportedOn==CONSENSUS.getPenalizedNum(branch, lastPeriod, msg.sender)):", 
            "        if(newAfterRep <= 0):", 
            "            newAfterRep = 0", 
            "            EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, msg.sender, lastPeriod)", 
            "        CONSENSUS.increaseDenominator(branch, lastPeriod, newAfterRep)", 
            "        totalRepDifference = newAfterRep - oldRep", 
            "        if(repBalance + totalRepDifference <= 0):", 
            "            totalRepDifference = -1*repBalance", 
            "        if(totalRepDifference<0):", 
            "            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]", 
            "            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)", 
            "            # sends that rep to the branch", 
            "            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)", 
            "    return(1)", 
            "", 
            "# Calculates the proportion of correct reports for a binary forked event", 
            "def proportionCorrectForkEvent(event):", 
            "    refund()", 
            "    p = 0", 
            "    outcome = catch(EVENTS.getForkOutcome(event))", 
            "    if(outcome!=0):", 
            "        # binary", 
            "        if(EVENTS.getNumOutcomes(event)==2 and EVENTS.getMaxValue(event)==TWO and EVENTS.getMinValue(event)==ONE):", 
            "            # subtract 1 to get it from 0 to 1", 
            "            avgOutcome = EVENTS.getForkOutcome(event) - ONE", 
            "            # say we have outcome of 0, avg is .4, what is p?", 
            "            # p is .6 or 60%", 
            "            if(outcome == ONE):", 
            "                p = ONE - avgOutcome", 
            "            # say we have outcome of 1, avg is .8, what is p (proportion correct)?", 
            "            # p is .8 or 80%", 
            "            if(outcome == 2 * ONE):", 
            "                p = avgOutcome", 
            "            if(outcome == 3 * ONEHALF):", 
            "                return(0)", 
            "        return(p)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "### Helper functions:", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeOnForkedEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "proportionCorrectForkEvent(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern forkPenalize: [penalizeOnForkedEvent:[int256,int256]:int256, proportionCorrectForkEvent:[int256]:int256, test_callstack:[]:int256]"
    }, 
    "forking": {
        "address": "0x2e5a882aa53805f1a9da3cf18f73673bca98fa0f", 
        "code": [
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern sendReputation: [allowance:[int256,int256]:int256, approve:[int256,int256,int256]:int256, convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendReputation:[int256,int256,int256]:int256, test_callstack:[]:int256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]", 
            "SENDREP = 0x9308cf21b5a11f182f9707ca284bbb71bb84f893", 
            "extern roundTwo: [resolve:[int256,int256]:int256, roundTwoPostBond:[int256,int256,int256,int256]:int256, roundTwoResolve:[int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "ROUNDTWO = 0x7d4b581a0868204b7481c316b430a97fd292a2fb", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern createBranch: [createSubbranch:[bytes,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CREATEBRANCH = 0x9fe69262bbaa47f013b7dbd6ca5f01e17446c645", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUSDATA = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "inset('refund.se')", 
            "", 
            "macro POINTZEROONE: 10000000000000000", 
            "", 
            "# UI has to handle function calls for these", 
            "", 
            "#Notes:", 
            "    #Anyone can pay some amount significantly greater than the bond amount to force a branching event, splitting rep into two classes.", 
            "    #In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.", 
            "    #In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.", 
            "    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.", 
            "", 
            "# Period where we forked, at the end of it", 
            "    # don't penalize for this period / anything that happened here should be considered to not have happened - done", 
            "    # let period be incremented as normal - done", 
            "    # no rep redistribution on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done", 
            "    # fork users get a free pass for not reporting on this period - done", 
            "# Period after fork where we need to do nothing while waiting for fork to resolve", 
            "    # free pass for not reporting during this period in og branch - done, UI needs to call penalizeWrong with a 0 as event param or todo do this contract side after doing penalize wrong", 
            "    # no reporting or rep redistribution in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done", 
            "# Period after fork is resolved", 
            "    # markets can't be moved until now - done", 
            "    # all markets have early exp disabled until this point - done", 
            "    # each event which should've resolved in the past 2 periods and this one is pushed up into this period and voted on in period after this - done", 
            "        # stays in parent if it wins, otherwise goes to new fork - done", 
            "    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done", 
            "# todo if already moved once don't allow again after another fork", 
            "def move_event(event):", 
            "    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))", 
            "    branch = EVENTS.getEventBranch(event)", 
            "    eventForkedOver = BRANCHES.getEventForkedOver(branch)", 
            "    expPeriod = EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch)", 
            "    eventIndex = EXPEVENTS.getEventIndex(expPeriod, event)", 
            "    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)", 
            "    if(forkPeriod && currentPeriod == (forkPeriod+2) && !EVENTS.getOutcome(event) && !BACKSTOPS.getMoved(event)):", 
            "        winner = BACKSTOPS.getResolved(branch, forkPeriod)", 
            "        if(winner==0):", 
            "            winner = self.resolve_fork(branch)", 
            "        BACKSTOPS.setMoved(event)", 
            "        if(event == eventForkedOver):", 
            "            return(1)", 
            "        elif(winner == EVENTS.getEventBranch(event)):", 
            "            # set outcomes to 0", 
            "            EVENTS.setOutcome(event, 0)", 
            "            EVENTS.setmode(event, 0)", 
            "            EVENTS.setEthics(event, 0)", 
            "            EVENTS.setUncaughtOutcome(event, 0)", 
            "            # return bond if it's a round 2 event and make it not one anymore", 
            "            ROUNDTWO.roundTwoResolve(branch, event, eventIndex)", 
            "", 
            "            # leave event here", 
            "            # if should've resolved in past periods", 
            "            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):", 
            "                # push it into next [this] period", 
            "                EXPEVENTS.addEvent(branch, currentPeriod, eventID)", 
            "                EVENTS.setExpiration(event, block.timestamp)", 
            "            # otherwise it's set to expire in the period it would've expired in as normal, no changes needed", 
            "        else:", 
            "            EVENTS.setBranch(event, winner)", 
            "            # set outcomes to 0", 
            "            EVENTS.setOutcome(event, 0)", 
            "            EVENTS.setmode(event, 0)", 
            "            EVENTS.setEthics(event, 0)", 
            "            EVENTS.setUncaughtOutcome(event, 0)", 
            "            # return bond if it's a round 2 event and make it not one anymore", 
            "            ROUNDTWO.roundTwoResolve(branch, event, eventIndex)", 
            "", 
            "            # move event to fork", 
            "            # and place it into the next reporting period w/ outcomes to 0", 
            "            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):", 
            "                # push it into next [this] period", 
            "                EXPEVENTS.addEvent(branch, currentPeriod, eventID)", 
            "                EVENTS.setExpiration(event, block.timestamp)", 
            "            else:", 
            "                # push into period it wouldve expired in", 
            "                EXPEVENTS.addEvent(branch, expPeriod, eventID)", 
            "                # expiration time doesnt need to change", 
            "    else:", 
            "        return(0)", 
            "", 
            "# parent branch is branch here", 
            "# todo fork use address picked in market creation to resolve it and have a default fork resolve option", 
            "def resolve_fork(branch):", 
            "    # do whitelist", 
            "    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))", 
            "    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)", 
            "    origCap = self.exchangeRate(branch)", 
            "    fork = REPORTING.getFork(branch)", 
            "    forkCap = self.exchangeRate(fork)", 
            "    if(origcap >= forkCap):", 
            "        winner = branch", 
            "        BACKSTOPS.setResolved(branch, forkPeriod, winner)", 
            "        return(winner)", 
            "    else:", 
            "        winner = fork", 
            "        BACKSTOPS.setResolved(branch, forkPeriod, winner)", 
            "        return(winner)", 
            "", 
            "# Resolve fork method that gets exchange rate", 
            "def exchangeRate(branch):", 
            "    # get rep exchange rate from etherex for (branch)", 
            "    #return(exchangeRate)", 
            "    # for testing we'll just rng the exchange rate :)", 
            "    return(sha3(branch))", 
            "", 
            "# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back", 
            "# bond is 1% of rep", 
            "def fork(event, branch, forkedOverEthicality):", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)", 
            "    # no fork for 1 period after a fork", 
            "    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1) or currentPeriod == (forkPeriod+2)):", 
            "        return(-3)", 
            "    if(!EVENTS.getRoundTwo(event) || EVENTS.getFinal(event) || EVENTS.getForked(event)):", 
            "        return(-1)", 
            "    if(EVENTS.getBranch(event)!=branch):", 
            "        return(0)", 
            "    # todo find actual gas cost for resolution here and charge that", 
            "    if(msg.value < 200000*tx.gasprice):", 
            "        return(0)", 
            "    send(CONSENSUSDATA, msg.value)", 
            "    CONSENSUSDATA.setRefund(event, msg.value)", 
            "    # if pushed forward event don't allow", 
            "    if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event)):", 
            "        return(-4)", 
            "    # if in last 48 hr of period", 
            "    if(block.timestamp/BRANCHES.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/BRANCHES.getPeriodLength(branch)) && EVENTS.getUncaughtOutcome(event)!=0 && !EVENTS.getForked(event)):", 
            "        bond = POINTZEROONE*REPORTING.getTotalRep(branch)/ONE", 
            "        BACKSTOPS.setBondAmount(event, bond)", 
            "        # lose fork bond in branch 1", 
            "        # results same as roundtwobond, let it resolve as that on original network", 
            "        if(SENDREP.sendReputation(branch, event, bond)==0):", 
            "            return(-2)", 
            "        # on branch 2 fork bond isn't lost", 
            "        # on fork bond isn't lost, gets paid up to 2x from \"liars\"", 
            "        # make the fork", 
            "        newBranch = CREATEBRANCH.createSubbranch(text(\"fork\"), BRANCHES.getPeriodLength(branch), branch, BRANCHES.getMinTradingFee(branch), 0)", 
            "        REPORTING.setFork(newBranch)", 
            "        period = BRANCHES.getVotePeriod(newBranch)", 
            "        EXPEVENTS.setEventRequired(newBranch, period+1, event)", 
            "        EXPEVENTS.addEvent(newBranch, period+1, event)", 
            "        EVENTS.setExpiration(event, block.timestamp)", 
            "        BACKSTOPS.setOriginalBranch(event, branch)", 
            "        BACKSTOPS.setForkBondPoster(event, msg.sender)", 
            "        EVENTS.setForked(event)", 
            "        BACKSTOPS.setFinal(event)", 
            "        BRANCHES.setForkPeriod(branch)", 
            "        BRANCHES.setForkPeriod(newBranch)", 
            "        BRANCHES.setEventForkedOver(newBranch, event)", 
            "        BRANCHES.setEventForkedOver(branch, event)", 
            "        if(forkedOverEthicality):", 
            "            BACKSTOPS.setForkedOverEthicality(event)", 
            "        # return round 2 bond on orig. branch", 
            "        market = EVENTS.getMarket(event, 0)", 
            "        avgAdjCost = BRANCHES.getInitialBalance(branch, period-1)/EXPEVENTS.getNumberEvents(branch, period-1)", 
            "        bond = avgAdjCost + MARKETS.getSharesValue(market)*(POINTZEROONE + MARKETS.getTradingFee(market)/2) / ONE", 
            "        bond = min(bond, 200*ONE)", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)", 
            "        BACKSTOPS.setBondReturned(event)", 
            "    else:", 
            "        return(0)", 
            "", 
            "", 
            "# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won", 
            "# branch is orig. branch", 
            "def resolveForkedEvent(branch, event):", 
            "    refund()", 
            "    bond = 100*ONE", 
            "    votedOnAgain = 0", 
            "    # checks for orig. branch", 
            "    if(EVENTS.getBranch(event)!=branch or BRANCHES.getEventForkedOver(branch)!=event):", 
            "        return(0)", 
            "    if(BRANCHES.getVotePeriod(branch) > (EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch))):", 
            "        votedOnAgain = 1", 
            "    if(!EVENTS.getForked(event)):", 
            "        return(-1)", 
            "    if(self.resolveForkEvent(branch, event)):", 
            "        EVENTS.setForkDone(event)", 
            "        CONSENSUSDATA.doRefund(msg.sender, event)", 
            "        return(1)", 
            "    # fork not done yet", 
            "    else:", 
            "        return(0)", 
            "", 
            "# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won", 
            "def resolveForkEvent(branch, event):", 
            "    refund()", 
            "    # whitelist", 
            "    bond = EVENTS.getBond(event)", 
            "    winner = BACKSTOPS.getResolved(branch, BRANCHES.getForkPeriod(branch))", 
            "    if(!winner):", 
            "        return(-5)", 
            "    # binary", 
            "    if(binary(event)):", 
            "        fxpOutcome = 0", 
            "        ethical = 0", 
            "        # original parent won", 
            "        if(winner==branch):", 
            "            fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "            ethical = ethic_catch(EVENTS.getEthical(event))", 
            "        # fork won", 
            "        else:", 
            "            fxpOutcome = catch(EVENTS.getForkOutcome(event))", 
            "            ethical = ethic_catch(EVENTS.getForkEthicality(event))", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        EVENTS.setEthics(event, ethical)", 
            "        if(fxpOutcome==3*ONEHALF || !ethical):", 
            "            # give event bond money to reporters", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(branch, bond)", 
            "            # not ethical is same as .5 outcome", 
            "            fxpOutcome = 3*ONEHALF", 
            "            EVENTS.setOutcome(event, fxpOutcome)", 
            "        else:", 
            "            # return bond", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(INFO.getCreator(event), bond)", 
            "        return(1)", 
            "    # scalar", 
            "    elif(scalar(event) or categorical(event)):", 
            "        mode = 0", 
            "        ethical = 0", 
            "        # original parent won", 
            "        if(winner==branch):", 
            "            mode = EVENTS.getUncaughtOutcome(event)", 
            "            ethical = ethic_catch(EVENTS.getEthical(event))", 
            "        # fork won", 
            "        else:", 
            "            mode = EVENTS.getForkOutcome(event)", 
            "            ethical = ethic_catch(EVENTS.getForkEthicality(event))", 
            "        EVENTS.setmode(event, mode)", 
            "        EVENTS.setEthics(event, ethical)", 
            "        scaled_max = EVENTS.getMaxValue(event)", 
            "        scaled_min = EVENTS.getMinValue(event)", 
            "        if(categorical(event)):", 
            "            scaled_min = ONE", 
            "            scaled_max = ONE*EVENTS.getNumOutcomes(event)", 
            "        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min", 
            "        ethicOutcome = ONEHALF * (scaled_max - scaled_min)/ONE + scaled_min", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        if(mode==ONEHALF || !ethical):", 
            "            # give event bond money to reporters", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(branch, bond)", 
            "            # not ethical is same as .5 outcome", 
            "            EVENTS.setOutcome(event, ethicOutcome)", 
            "        else:", 
            "            # return bond", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(INFO.getCreator(event), bond)", 
            "        return(1)", 
            "    # (should never be reached)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "exchangeRate(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkedOverEthicality", 
                        "type": "int256"
                    }
                ], 
                "name": "fork(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "move_event(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveForkEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveForkedEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "resolve_fork(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern forking: [exchangeRate:[int256]:int256, fork:[int256,int256,int256]:int256, move_event:[int256]:int256, resolveForkEvent:[int256,int256]:int256, resolveForkedEvent:[int256,int256]:int256, resolve_fork:[int256]:int256, test_callstack:[]:int256]"
    }, 
    "fxpFunctions": {
        "address": "0xe5b327630cfa7f4b2324f9066c897dceecfd88a3", 
        "code": [
            "inset('refund.se')", 
            "", 
            "macro fx_exp2_small($x):", 
            "    with $result = 0xDE0B6B3A7640000:", 
            "        with $temp = $x:", 
            "            $result += 0x99E8DB03256CE5D*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x35574BC3CEE1B29*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0xC530B1588A9744*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x222BA330DD3238*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x4BCAE17B0E026*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x8C1823930274*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0xDDF4DC74E60*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x133B271CDC3*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x17B29A01C3*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x1A4856BBF*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x1A7B0EF3*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x18B0114*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x13598A*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result + 0x1772E*$temp / 0xDE0B6B3A7640000", 
            "", 
            "macro fx_exp2($x):", 
            "    with $y = $x / 0xDE0B6B3A7640000:", 
            "        with $z = $x % 0xDE0B6B3A7640000:", 
            "            fx_exp2_small($z) * 2**$y", 
            "", 
            "macro fx_exp($x):", 
            "    fx_exp2($x * 0xDE0B6B3A7640000 / 0x99E8DB03256CE5D)", 
            "", 
            "macro fx_floor_log2($x):", 
            "    with $y = $x / 0xDE0B6B3A7640000:", 
            "        with $lo = 0:", 
            "            with $hi = 195:", 
            "                with $mid = ($hi + $lo)/2:", 
            "                    while (($lo + 1) != $hi):", 
            "                        if $y < 2**$mid:", 
            "                            $hi = $mid", 
            "                        else:", 
            "                            $lo = $mid", 
            "                        $mid = ($hi + $lo)/2", 
            "                    $lo", 
            "", 
            "macro fx_log2_small($x):", 
            "    with $result = -0x3A1FC51916C688B3:", 
            "        with $temp = $x:", 
            "            $result += 0xC565F219AF5978B2*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result -= 0x1C1D8598D667FDA01*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x345818200705A646C*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result -= 0x4B0C797AB63C59115*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x531D5B0D773470D90*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result -= 0x479AEAF9DC2035C87*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x3023A4D6640FB61C5*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result -= 0x193016839200ECECC*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0xA286AE6FEC49021A*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result -= 0x319100C46AD3846C*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0xB0F2D8D21D2BDB2*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result -= 0x1B42116FA4CEA01*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result += 0x29772EF1112E47*$temp / 0xDE0B6B3A7640000", 
            "            $temp = $temp*$x / 0xDE0B6B3A7640000", 
            "            $result - 0x1D57FAAD753FF*$temp / 0xDE0B6B3A7640000", 
            "", 
            "macro fx_log2($x):", 
            "    with $y = fx_floor_log2($x):", 
            "        with $z = $x / 2**$y:", 
            "            $y * 0xDE0B6B3A7640000 + fx_log2_small($z)", 
            "", 
            "macro fx_log($x):", 
            "    fx_log2($x) * 0xDE0B6B3A7640000 / 0x14057B7EF767814F", 
            "", 
            "# Calculates the exponential function given a fixed point [base 10^18] number, so e^x", 
            "def fx_exp(x):", 
            "    refund()", 
            "    return(fx_exp(x))", 
            "", 
            "# Calculates the natural log function given a fixed point [base 10^18] number, so ln(x)", 
            "def fx_log(x):", 
            "    refund()", 
            "    return(fx_log(x))", 
            "", 
            "# Takes the square root of a fixed point number", 
            "def sqrt(n):", 
            "    refund()", 
            "    val = n", 
            "    i = 0", 
            "    while i < 11:", 
            "        val = (val + n*ONE/val)/2", 
            "        i += 1", 
            "    return val"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_exp(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_log(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "n", 
                        "type": "int256"
                    }
                ], 
                "name": "sqrt(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256, test_callstack:[]:int256]"
    }, 
    "info": {
        "address": "0x8a4e2993a9972ee035453bb5674816fc3a698718", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "inset('refund.se')", 
            "", 
            "# Every entity in our contract has similar metadata.", 
            "# Instead of putting it in each entity, we put all the metadata here.", 
            "# Info's index is the hash of the item we're getting info on", 
            "data Info[](description[2048], descriptionLength, creator, creationFee)", 
            "", 
            "def init():", 
            "    description = text(\"Root branch\")", 
            "    save(self.Info[1010101].description[0], description, chars=len(description))", 
            "    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826", 
            "    self.Info[1010101].creationFee = 10", 
            "    self.Info[1010101].descriptionLength = len(description)", 
            "", 
            "def getDescription(ID):", 
            "    refund()", 
            "    length=self.Info[ID].descriptionLength", 
            "    return(load(self.Info[ID].description[0], chars=length): str)", 
            "", 
            "def getDescriptionLength(ID):", 
            "    refund()", 
            "    return(self.Info[ID].descriptionLength)", 
            "", 
            "def getCreator(ID):", 
            "    refund()", 
            "    return(self.Info[ID].creator)", 
            "", 
            "def getCreationFee(ID):", 
            "    refund()", 
            "    return(self.Info[ID].creationFee)", 
            "", 
            "# @return 1 if success, 0 if creator already exists", 
            "def setInfo(ID, description: str, creator, fee):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #   return(-1)", 
            "    # check that msg.sender is one of our function contracts", 
            "    if(self.Info[ID].creator == 0):", 
            "        if len(description):", 
            "            save(self.Info[ID].description[0], description, chars=len(description))", 
            "            self.Info[ID].descriptionLength = len(description)", 
            "        self.Info[ID].creationFee = fee", 
            "        self.Info[ID].creator = creator", 
            "        return(1)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreator(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescription(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescriptionLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "creator", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setInfo(int256,bytes,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "makeReports": {
        "address": "0x70a893eb9569041e97a3787f0c76a1eb6378d8b2", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "extern penalizationCatchup: [penalizationCatchup:[int256,int256]:int256, test_callstack:[]:int256]", 
            "CATCHUP = 0xabe47f122a496a732d6c4b38b3ca376d597d75dd", 
            "extern reportingThreshold: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getEventCanReportOn:[int256,int256,int256,int256]:int256, getEventsToReportOn:[int256,int256,int256,int256]:int256[], setReportingThreshold:[int256]:int256, test_callstack:[]:int256]", 
            "THRESHOLD = 0x5f67ab9ff79be97b27ac8f26ef9f4b429b82e2df", 
            "inset('refund.se')", 
            "inset('logReturn.se')", 
            "", 
            "event submittedReportHash(sender: indexed, branch: indexed, event: indexed, reportHash, encryptedReport, encryptedSalt, ethics, timestamp)", 
            "event submittedReport(sender: indexed, branch: indexed, event: indexed, salt, report, ethics, timestamp)", 
            "event makeReports_logReturn(returnValue)", 
            "", 
            "macro MAX_THRESHOLD: 10^54", 
            "", 
            "def makeHash(salt, report, eventID, sender):", 
            "    hashInfo = array(4)", 
            "    hashInfo[0] = sender", 
            "    hashInfo[1] = salt", 
            "    hashInfo[2] = report", 
            "    hashInfo[3] = eventID", 
            "    reportHash = sha3(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# Allows a user to submit the hash of their report / commit", 
            "# Error: 0: not caught up on rep redistributions", 
            "# Error -1: invalid event", 
            "# Error -2: not in first half of period [commit part]", 
            "# Error -3: not eligible to report on this event", 
            "def submitReportHash(event, reportHash, encryptedReport, encryptedSalt, ethics):", 
            "    branch = EVENTS.getBranch(event)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "", 
            "    # makes sure a user is up to date on penalizations", 
            "    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    if(delta > 1):", 
            "        if(CATCHUP.penalizationCatchup(branch, msg.sender)!=1):", 
            "            return(0)", 
            "    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):", 
            "        return(0)", 
            "", 
            "    # if first report of period, num events not set", 
            "    if(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):", 
            "        EXPEVENTS.setNumEventsToReportOn(branch)", 
            "        # set amount of fees to be distributed in this period from the branch", 
            "        BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))", 
            "    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(eventIndex==0 && (eventID==0 || event!=eventID)):", 
            "        return(-1)", 
            "    reportingThreshold = 0", 
            "", 
            "    # check if this is a backstop event", 
            "    if(EXPEVENTS.getRequired(event) || EVENTS.getReportingThreshold(event)):", 
            "        reportingThreshold = MAX_THRESHOLD", 
            "    else:", 
            "        if(EXPEVENTS.getLesserReportNum(branch, votePeriod, event)==0):", 
            "            THRESHOLD.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)", 
            "        reportingThreshold = THRESHOLD.calculateReportingThreshold(branch, event, votePeriod, msg.sender)", 
            "", 
            "    # do abs then mult by 2 to ensure pos. and between 0 and 1", 
            "    shaHash = sha3(msg.sender + event)", 
            "    # max value 10^54: 2^256 / 10^54 = 115792089237316195423570.985...", 
            "    shaHash = abs(shaHash) / 115792089237316195423571", 
            "    if(shaHash > reportingThreshold):", 
            "        return(-3)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual <= periodLength/2):", 
            "        EXPEVENTS.setReportHash(branch, votePeriod, msg.sender, reportHash, event)", 
            "        EXPEVENTS.setEncryptedReport(branch, votePeriod, msg.sender, encryptedReport, encryptedSalt, ethics, event)", 
            "        log(type=submittedReportHash, msg.sender, branch, event, reportHash, encryptedReport, encryptedSalt, ethics, block.timestamp)", 
            "        return(1)", 
            "    return(-2)", 
            "", 
            "# Submits / reveals a report for a period", 
            "# @return 1 if success", 
            "# Error messages", 
            "    # 0: reporter doesn't exist or has <1 rep", 
            "    # -1: has already reported", 
            "    # -2: not in second half of period [reveal part]", 
            "    # -3: hash doesn't match", 
            "    # -4: bad report", 
            "    # -5: invalid event", 
            "    # -6: already resolved", 
            "    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though", 
            "    # -8: fees couldn't be collected", 
            "def submitReport(event, salt, report, ethics):", 
            "    branch = EVENTS.getBranch(event)", 
            "    balance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(balance<ONE):", 
            "        logReturn(makeReports_logReturn, 0)", 
            "    if(EXPEVENTS.getReport(branch, votePeriod, event, msg.sender)):", 
            "        logReturn(makeReports_logReturn, -1)", 
            "    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)", 
            "    # makes sure event is in the given branch and vote period", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(eventIndex==0 && (eventID==0 || event!=eventID)):", 
            "        logReturn(makeReports_logReturn, -5)", 
            "    elif(EVENTS.getOutcome(event)!=0):", 
            "        logReturn(makeReports_logReturn, -6)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    # ensures user has collected fees for last reporting period", 
            "    if(!CONSENSUS.getFeesCollected(branch, msg.sender, votePeriod-1)):", 
            "        logReturn(makeReports_logReturn, -8)", 
            "    # commented out for testing", 
            "    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):", 
            "    #    logReturn(makeReports_logReturn, -7)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "        realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, event)", 
            "        if(self.makeHash(salt, report, eventID, msg.sender)!=realHash || realHash==0):", 
            "            logReturn(makeReports_logReturn, -3)", 
            "        forkedOverEthicality = BACKSTOPS.getForkedOverEthicality(event)", 
            "        forkedOverThisEvent = 0", 
            "        if(BRANCHES.getEventForkedOver(branch) == event):", 
            "            forkedOverThisEvent = 1", 
            "        roundTwo = BACKSTOPS.getRoundTwo(event)", 
            "        report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance)", 
            "        if(report == -4):", 
            "            logReturn(makeReports_logReturn, -4)", 
            "        EXPEVENTS.setReport(branch, votePeriod, eventID, report, msg.sender)", 
            "        # set ethics value for event", 
            "        ethics = ethics", 
            "        if(ethics!=ONE and ethics!=0):", 
            "            ethics = ONE", 
            "        # set ethicality for forked event", 
            "        if(forkedOverThisEvent):", 
            "            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality", 
            "            if(forkedOverEthicality):", 
            "                oldEthical = ethic_catch(EVENTS.getEthical(event))", 
            "                if(oldEthical == ONE):", 
            "                    ethics = 0", 
            "                else:", 
            "                    ethics = ONE", 
            "            EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)", 
            "            ethics = (EVENTS.getForkEthicality(event)*EXPEVENTS.getRepEvent(branch, votePeriod, event) + ethics*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, event) + balance)", 
            "            EVENTS.setForkEthicality(event, ethics)", 
            "        # set ethicality for a regular event", 
            "        else:", 
            "            EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)", 
            "            # weight by rep", 
            "            if(roundTwo):", 
            "                ethics = (EVENTS.getEthics(event)*EXPEVENTS.getRepEvent(branch, votePeriod, event) + ethics*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, event) + balance)", 
            "            # just a simple avg.", 
            "            else:", 
            "                ethics = (EVENTS.getEthics(event)*EXPEVENTS.getNumReportsEvent(branch, votePeriod, event) + ethics) / (EXPEVENTS.getNumReportsEvent(branch, votePeriod, event) + 1)", 
            "            EVENTS.setEthics(eventID, ethics)", 
            "        EXPEVENTS.addReportToEvent(branch, votePeriod, eventID, msg.sender)", 
            "        # round 2 and fork events are weighted by rep", 
            "        if(roundTwo or forkedOverThisEvent):", 
            "            EXPEVENTS.addRepEvent(branch, votePeriod, event, EXPEVENTS.getBeforeRep(branch, votePeriod, msg.sender))", 
            "        reportsNum = EXPEVENTS.getLesserReportNum(branch, votePeriod, event)", 
            "        paidBack = EXPEVENTS.getReportersPaidSoFar(branch, event)", 
            "        diff = reportsNum - paidBack", 
            "        # used to pay reporters after reporting for their gas costs", 
            "        if(diff >= 1):", 
            "            EXPEVENTS.addReportersPaidSoFar(branch, event)", 
            "            CASH.subtractCash(branch, 3500000*tx.gasprice)", 
            "            CASH.addCash(msg.sender, 3500000*tx.gasprice)", 
            "        log(type=submittedReport, msg.sender, branch, event, salt, report, ethics, block.timestamp)", 
            "        logReturn(makeReports_logReturn, 1)", 
            "    logReturn(makeReports_logReturn, -2)", 
            "", 
            "# validates and submits report", 
            "# weights reports by rep if round 2 and fork", 
            "# Returns -4 if report is invalid", 
            "    # isn't between 1 and 2 if binary", 
            "    # if same report as original outcome / ethicality if a forked event not forked over ethicality it's also invalid b/c this option was removed as a poss. answer", 
            "def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance):", 
            "    outcome = 0", 
            "    # binary", 
            "    if(EVENTS.getNumOutcomes(eventID)==2 and EVENTS.getMaxValue(eventID)==TWO && EVENTS.getMinValue(eventID)==ONE):", 
            "        if(report>2*ONE or report<ONE or report==0):", 
            "            return(-4)", 
            "        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "        elif(forkedOverThisEvent):", 
            "            # in case of fork remove the original outcome as a possible response if didn't fork over ethics", 
            "            if(!forkedOverEthicality && report == catch(EVENTS.getUncaughtOutcome(eventID))):", 
            "                return(-4)", 
            "            outcome = (EVENTS.getForkOutcome(eventID)*EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + report*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + balance)", 
            "            EVENTS.setForkOutcome(eventID, outcome)", 
            "        else:", 
            "            if(roundTwo):", 
            "                outcome = (EVENTS.getUncaughtOutcome(eventID)*EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + report*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + balance)", 
            "            else:", 
            "                outcome = (EVENTS.getUncaughtOutcome(eventID)*EXPEVENTS.getNumReportsEvent(branch, votePeriod, eventID) + report) / (EXPEVENTS.getNumReportsEvent(branch, votePeriod, eventID) + 1)", 
            "            EVENTS.setUncaughtOutcome(eventID, outcome)", 
            "    # scalar or categorical", 
            "    else:", 
            "        if(report > ONE):", 
            "            report = ONE", 
            "        elif(report<=0):", 
            "            # 1 is the new 0 [1/10**18 is basically 0 but able to be differentiated from no report of 0]", 
            "            report = 1", 
            "        if(forkedOverThisEvent):", 
            "            # in case of fork remove the original outcome as a possible response if didn't fork over ethics", 
            "            if(!forkedOverEthicality && report == EVENTS.getUncaughtOutcome(eventID)):", 
            "                return(-4)", 
            "            # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "            EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, balance)", 
            "            if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):", 
            "                EXPEVENTS.setCurrentMode(votePeriod, eventID, report)", 
            "                EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)", 
            "            outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)", 
            "            EVENTS.setForkOutcome(eventID, outcome)", 
            "        else:", 
            "            if(roundTwo):", 
            "                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "                EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, balance)", 
            "                if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):", 
            "                    EXPEVENTS.setCurrentMode(votePeriod, eventID, report)", 
            "                    EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)", 
            "                outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)", 
            "            else:", 
            "                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "                EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, 1)", 
            "                if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):", 
            "                    EXPEVENTS.setCurrentMode(votePeriod, eventID, report)", 
            "                    EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)", 
            "                outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)", 
            "            EVENTS.setUncaughtOutcome(eventID, outcome)", 
            "    return(report)", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "makeHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReport(int256,int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "encryptedReport", 
                        "type": "int256"
                    }, 
                    {
                        "name": "encryptedSalt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkedOverEthicality", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkedOverThisEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "roundTwo", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "validateReport(int256,int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": false, 
                        "name": "returnValue", 
                        "type": "int256"
                    }
                ], 
                "name": "makeReports_logReturn(int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "ethics", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "submittedReport(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "encryptedReport", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "encryptedSalt", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "ethics", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "submittedReportHash(int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern makeReports: [makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:_, submitReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "markets": {
        "address": "0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See thes", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# import topics as TOPICS", 
            "", 
            "inset('refund.se')", 
            "", 
            "# Markets' index is the marketID, markets stores data about markets [which are able to be traded on] in augur", 
            "    # Events is a 0 indexed array of events in the market in the format of", 
            "        # [1, event, event, 2, event, 3, event, event, event]", 
            "        # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events", 
            "    # Sharespurchased keeps track of the number of shares purchased for each outcome", 
            "        # sharesPurchased states starts at 1 - (same for participants[].shares[] array)", 
            "    # Participants is an array of participants, their addresses as keys and the shares in each outcome they've purchased of an event as the values", 
            "    \t# e.g. participants[addr].shares[1]", 
            "    # currentParticipant is the number of participants [traders] in the market", 
            "    # cumulativeScale == range of the market for scalars", 
            "    # numOutcomes is the number of outcomes in a market [up to 8 for now]", 
            "    # a binary outcome state 1 is no, 2 is true, 0 if not done, 1.5 if indeterminate", 
            "    # tradingFee is a percent in fixedPoint and the base trading fee for a market: takers pay 100%-150% of this, makers pay 0-50% of this", 
            "    # tradingPeriod is which eventExpPeriod market expires in", 
            "    # pushing forward is whether a market has been pushed forward to attempt early resolution", 
            "    # bondsman is the person/address who/that posted the early resolution bond", 
            "    # originalPeriod is the original period the market's event would resolve in", 
            "    # trade_ids stores trades for a given market", 
            "    # last_trade is the last trade that happened in a given market", 
            "    # total_trades is the total number of trades in a give market", 
            "    # tags are the subject tags / categories / keywords for a given market", 
            "    # makerFees - from 0-50% - amount of fee that the maker orders pay", 
            "    # extraInfo is any extra info that didn't fit well in the regular description", 
            "    # sharesValue is the value of the shares traded in a given market", 
            "    # gasSubsidy is paid by the creator to pay for closing the market [closing is just setting the winning outcomes and allowing people to withdraw funds if they own winning shares]", 
            "    # fees is total amount of fees a market has paid to a branch [the reporters]", 
            "    # lastExpDate is when the market's last event expires", 
            "    # prices keeps track of the latest traded price for a given outcome in a market", 
            "data Markets[](events[], lenEvents, sharesPurchased[], participants[](shares[]), winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, creationBlock, creationTime, lastExpDate, prices[])", 
            "", 
            "def addFees(market, amount):", 
            "    self.Markets[market].fees += amount", 
            "    return(1)", 
            "", 
            "def setPrice(market, outcome, price):", 
            "    self.Markets[market].prices[outcome] = price", 
            "    return(1)", 
            "", 
            "# refund closing cost for a market", 
            "def refundClosing(market, to):", 
            "    subsidy = self.Markets[market].gasSubsidy", 
            "    self.Markets[market].gasSubsidy -= subsidy", 
            "    send(subsidy, to)", 
            "    return(1)", 
            "", 
            "def getLastExpDate(market):", 
            "\treturn(self.Markets[market].lastExpDate)", 
            "", 
            "def getLastOutcomePrice(market, outcome):", 
            "\treturn(self.Markets[market].prices[outcome])", 
            "", 
            "def getFees(market):", 
            "    return(self.Markets[market].fees)", 
            "", 
            "def getMakerFees(market):", 
            "    return(self.Markets[market].makerFees)", 
            "", 
            "def getgasSubsidy(market):", 
            "    return(self.Markets[market].gasSubsidy)", 
            "", 
            "def getSharesValue(market):", 
            "    return(self.Markets[market].sharesValue)", 
            "", 
            "def returnTags(market):", 
            "    tags = array(3)", 
            "    tags[0] = self.Markets[market].tag1", 
            "    tags[1] = self.Markets[market].tag2", 
            "    tags[2] = self.Markets[market].tag3", 
            "    return(tags: arr)", 
            "", 
            "def getTopic(market):", 
            "    return(self.Markets[market].tag1)", 
            "", 
            "def getTotalSharesPurchased(market):", 
            "    refund()", 
            "    total = 0", 
            "    n = self.Markets[market].numOutcomes", 
            "    i = 1", 
            "    while i <= n:", 
            "      total += self.Markets[market].sharesPurchased[i]", 
            "      i += 1", 
            "    return(total)", 
            "", 
            "def getMarketEvent(market, index):", 
            "    refund()", 
            "    return(self.Markets[market].events[index])", 
            "", 
            "def getCreationTime(market):", 
            "    return(self.Markets[market].creationTime)", 
            "", 
            "def getCreationBlock(market):", 
            "    return(self.Markets[market].creationBlock)", 
            "", 
            "def getMarketEvents(market):", 
            "    refund()", 
            "    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)", 
            "", 
            "def getSharesPurchased(market, outcome):", 
            "    refund()", 
            "    return(self.Markets[market].sharesPurchased[outcome])", 
            "", 
            "def getExtraInfoLength(market):", 
            "    return(self.Markets[market].extraInfoLen)", 
            "", 
            "def getExtraInfo(market):", 
            "    refund()", 
            "    length=self.Markets[market].extraInfoLen", 
            "    return(load(self.Markets[market].extraInfo[0], chars=length): str)", 
            "", 
            "def getVolume(market):", 
            "    refund()", 
            "    return(self.Markets[market].volume)", 
            "", 
            "def getParticipantSharesPurchased(market, trader, outcome):", 
            "    refund()", 
            "    return(self.Markets[market].participants[trader].shares[outcome])", 
            "", 
            "def getNumEvents(market):", 
            "    refund()", 
            "    return(self.Markets[market].lenEvents)", 
            "", 
            "def getCumScale(market):", 
            "    refund()", 
            "    return(self.Markets[market].cumulativeScale)", 
            "", 
            "def getMarketNumOutcomes(market):", 
            "    refund()", 
            "    return(self.Markets[market].numOutcomes)", 
            "", 
            "def getTradingPeriod(market):", 
            "    refund()", 
            "    return(self.Markets[market].tradingPeriod)", 
            "", 
            "def getOriginalTradingPeriod(market):", 
            "    refund()", 
            "    return(self.Markets[market].originalPeriod)", 
            "", 
            "def setTradingPeriod(market, period):", 
            "    refund()", 
            "    self.Markets[market].tradingPeriod = period", 
            "    return(1)", 
            "", 
            "def getTradingFee(market):", 
            "    refund()", 
            "    return(self.Markets[market].tradingFee)", 
            "", 
            "def getBranchID(market):", 
            "    refund()", 
            "    return(self.Markets[market].branch)", 
            "", 
            "macro market($marketID):", 
            "    self.Markets[$marketID]", 
            "", 
            "macro cumScale($marketID):", 
            "    market($marketID).cumulativeScale", 
            "", 
            "macro numOutcomes($marketID):", 
            "    market($marketID).numOutcomes", 
            "", 
            "macro sharesPurchased($marketID):", 
            "    market($marketID).sharesPurchased", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, lastExpDate):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add event list to the market", 
            "    save(self.Markets[marketID].events[0], events, items=len(events))", 
            "    self.Markets[marketID].lenEvents = len(events)", 
            "    save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))", 
            "    self.Markets[marketID].extraInfoLen = len(extraInfo)", 
            "    self.Markets[marketID].tradingPeriod = tradingPeriod", 
            "    self.Markets[marketID].originalPeriod = tradingPeriod", 
            "    self.Markets[marketID].tradingFee = tradingFee", 
            "    self.Markets[marketID].branch = branch", 
            "    self.Markets[marketID].cumulativeScale = cumScale", 
            "    self.Markets[marketID].numOutcomes = numOutcomes", 
            "    self.Markets[marketID].tag1 = tag1", 
            "    self.Markets[marketID].tag2 = tag2", 
            "    self.Markets[marketID].gasSubsidy = gasSubsidy", 
            "    self.Markets[marketID].tag3 = tag3", 
            "    self.Markets[marketID].makerFees = makerFees", 
            "    self.Markets[marketID].fees = creationFee", 
            "    self.Markets[marketID].creationTime = block.timestamp", 
            "    self.Markets[marketID].creationBlock = block.number", 
            "    self.Markets[marketID].lastExpDate = lastExpDate", 
            "    return(1)", 
            "", 
            "def modifyShares(marketID, outcome, amount):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    sharesPurchased(marketID)[outcome] += amount", 
            "    return(1)", 
            "", 
            "def modifySharesValue(marketID, amount):", 
            "    self.Markets[marketID].sharesValue += amount", 
            "    return(1)", 
            "", 
            "def modifyParticipantShares(marketID, trader, outcome, amount, cancel):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].participants[trader].shares[outcome] += amount", 
            "    if(amount<0):", 
            "        amount = amount*-1", 
            "    if(cancel):", 
            "        amount = -1*amount", 
            "    self.Markets[marketID].volume += amount", 
            "    return(1)", 
            "", 
            "def setWinningOutcomes(market, outcomes: arr):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))", 
            "    return(1)", 
            "", 
            "def getWinningOutcomes(market):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)", 
            "", 
            "def getOneWinningOutcome(market, num):", 
            "    refund()", 
            "    # whitelist", 
            "    return(self.Markets[market].winningOutcomes[num])", 
            "", 
            "def setTradingFee(market, fee):", 
            "    refund()", 
            "    self.Markets[market].tradingFee = fee", 
            "    return(fee)", 
            "", 
            "def setMakerFees(market, makerFees):", 
            "    refund()", 
            "    self.Markets[market].makerFees = makerFees", 
            "    return(makerFees)", 
            "", 
            "def setPushedForward(market, bool, sender):", 
            "    refund()", 
            "    self.Markets[market].pushingForward = bool", 
            "    self.Markets[market].bondsMan = sender", 
            "    return(1)", 
            "", 
            "def getPushedForward(market):", 
            "    refund()", 
            "    return(self.Markets[market].pushingForward)", 
            "", 
            "def getBondsMan(market):", 
            "    refund()", 
            "    return(self.Markets[market].bondsMan)", 
            "", 
            "def getLastTrade(market):", 
            "    refund()", 
            "    return(self.Markets[market].last_trade)", 
            "", 
            "def addTrade(market, trade_id, last_id):", 
            "    refund()", 
            "    self.Markets[market].trade_ids[last_id].next_id = trade_id", 
            "    self.Markets[market].trade_ids[trade_id].prev_id = last_id", 
            "    self.Markets[market].trade_ids[trade_id].id = trade_id", 
            "    self.Markets[market].last_trade = trade_id", 
            "    self.Markets[market].total_trades += 1", 
            "    return(1)", 
            "", 
            "def remove_trade_from_market(market_id, trade_id):", 
            "    refund()", 
            "    prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id", 
            "    next_id = self.Markets[market_id].trade_ids[trade_id].next_id", 
            "    if prev_id and next_id:", 
            "        self.Markets[market_id].trade_ids[prev_id].next_id = next_id", 
            "        self.Markets[market_id].trade_ids[next_id].prev_id = prev_id", 
            "    elif prev_id:", 
            "        self.Markets[market_id].last_trade = prev_id", 
            "        self.Markets[market_id].trade_ids[prev_id].next_id = 0", 
            "", 
            "    if next_id:", 
            "        self.Markets[market_id].trade_ids[trade_id].next_id = 0", 
            "    if prev_id:", 
            "        self.Markets[market_id].trade_ids[trade_id].prev_id = 0", 
            "    self.Markets[market_id].trade_ids[trade_id].id = 0", 
            "    self.Markets[market_id].total_trades -= 1", 
            "    return(1)", 
            "", 
            "def get_trade_ids(market_id, offset, numTradesToLoad):", 
            "    refund()", 
            "    numTrades = self.Markets[market_id].total_trades", 
            "    if offset > numTrades or numTrades == 0:", 
            "        return([]: arr)", 
            "    if numTradesToLoad == 0:", 
            "        numTradesToLoad = numTrades", 
            "    numTradesToLoad = min(numTradesToLoad, numTrades - offset)", 
            "    trade_id = self.Markets[market_id].last_trade", 
            "    if offset > 0:", 
            "        i = 0", 
            "        while i < offset:", 
            "            trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id", 
            "            i += 1", 
            "    trade_ids = array(numTradesToLoad)", 
            "    i = 0", 
            "    while i < numTradesToLoad:", 
            "        trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id", 
            "        trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id", 
            "        i = i + 1", 
            "    if trade_ids:", 
            "        return(trade_ids:arr)", 
            "    return([FAILURE]:arr)", 
            "", 
            "def get_total_trades(market_id):", 
            "    refund()", 
            "    return(self.Markets[market_id].total_trades)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addFees(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "last_id", 
                        "type": "int256"
                    }
                ], 
                "name": "addTrade(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondsMan(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationBlock(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationTime(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCumScale(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getExtraInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getExtraInfoLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getFees(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getLastExpDate(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getLastOutcomePrice(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getLastTrade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMakerFees(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "getOneWinningOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trader", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantSharesPurchased(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedForward(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesPurchased(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTopic(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalSharesPurchased(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getVolume(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getWinningOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market_id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_total_trades(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numTradesToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "get_trade_ids(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getgasSubsidy(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tradingPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cumScale", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "gasSubsidy", 
                        "type": "int256"
                    }, 
                    {
                        "name": "creationFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "lastExpDate", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeMarket(int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trader", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cancel", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyParticipantShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyShares(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifySharesValue(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "to", 
                        "type": "int256"
                    }
                ], 
                "name": "refundClosing(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }
                ], 
                "name": "remove_trade_from_market(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "returnTags(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }
                ], 
                "name": "setMakerFees(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }
                ], 
                "name": "setPrice(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bool", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedForward(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingFee(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingPeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcomes", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWinningOutcomes(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]"
    }, 
    "payout": {
        "address": "0x35152caa07026203a1add680771afb690d872d7d", 
        "code": [
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "inset('refund.se')", 
            "", 
            "event payout(sender:indexed, market:indexed, cashPayout, cashBalance, shares, timestamp)", 
            "", 
            "# Payout a trader in a market with one winning outcome [so not scalar]", 
            "# Error:", 
            "    # -1: sender doesn't exist / match up with the participant given participant number [this is used as a check to make sure participant #0 is really #0]", 
            "def oneOutcome(market, winningOutcome, sender, categoricalPointFive, numOutcomes):", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    # if it's an indeterminate categorical market resolve with all outcomes having an equal value", 
            "    if(categoricalPointFive):", 
            "        i = 0", 
            "        while(i < numOutcomes):", 
            "            sharesOwned = MARKETS.getParticipantSharesPurchased(market, sender, i+1)", 
            "            MARKETS.modifyParticipantShares(market, sender, i+1, -sharesOwned)", 
            "            cashPayout = sharesOwned*MARKETS.getCumScale(market)/(numOutcomes*ONE)", 
            "            CASH.subtractCash(market, cashPayout)", 
            "            CASH.addCash(sender, cashPayout)", 
            "            i+=1", 
            "    else:", 
            "        # distribute profit to the people who won money by holding winning shares", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, sender, winningOutcome)", 
            "        MARKETS.modifyParticipantShares(market, sender, winningOutcome, -sharesOwned)", 
            "        cashPayout = sharesOwned*cumScale/ONE", 
            "        CASH.subtractCash(market, cashPayout)", 
            "        CASH.addCash(sender, cashPayout)", 
            "    log(type=payout, sender, market, cashPayout, CASH.balance(sender), sharesOwned, block.timestamp)", 
            "    return(1)", 
            "", 
            "# Payout traders in markets with number of winningOutcomes of 2 [one scalar with any combination of binary + categorical for the other 2 dimensions, or just 1D with a scalar]", 
            "# Error:", 
            "    # -1: sender doesn't exist / match up with the participant given participant number [this is used as a check to make sure participant #0 is really #0]", 
            "def twoOutcomes(market, winningOutcome: arr, event, sender):", 
            "    refund()", 
            "    # fetch outcome and min/max values for the scalar", 
            "    outcome = EVENTS.getOutcome(event)", 
            "    minValue = EVENTS.getMinValue(event)", 
            "    maxValue = EVENTS.getMaxValue(event)", 
            "    # price is in fixed point", 
            "    # share two goes with the high/long side", 
            "    pricePerShare2 = ONE*(outcome - minValue) / (maxValue - minValue)", 
            "    # share one goes with the low/short side of the calc", 
            "    pricePerShare1 = ONE - pricePerShare1", 
            "    # for each winning outcome get rid of shares and send money to the trader", 
            "    n = 0", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    cashPayout = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, sender, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(market, sender, winningOutcome[n], -sharesOwned)", 
            "        # low side", 
            "        if(n==0):", 
            "            cashPayoutLow = sharesOwned*cumScale/ONE*pricePerShare1/ONE", 
            "            CASH.subtractCash(market, cashPayoutLow)", 
            "            CASH.addCash(sender, cashPayoutLow)", 
            "            cashPayout += cashPayoutLow", 
            "        # high side (of the scalar part)", 
            "        elif(n==1):", 
            "            cashPayoutHigh = sharesOwned*cumScale/ONE*pricePerShare2/ONE", 
            "            CASH.subtractCash(market, cashPayoutHigh)", 
            "            CASH.addCash(sender, cashPayoutHigh)", 
            "            cashPayout += cashPayoutHigh", 
            "        n+=1", 
            "    log(type=payout, sender, market, cashPayout, CASH.balance(sender), sharesOwned, block.timestamp)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "categoricalPointFive", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "oneOutcome(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "twoOutcomes(int256,int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cashPayout", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cashBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "shares", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "payout(int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern payout: [oneOutcome:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, twoOutcomes:[int256,int256[],int256,int256]:int256]"
    }, 
    "penalizationCatchup": {
        "address": "0xabe47f122a496a732d6c4b38b3ca376d597d75dd", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "", 
            "inset('refund.se')", 
            "", 
            "event penalizationCaughtUp(branch: indexed, sender: indexed, penalizedFrom, penalizedUpTo, repLost, newRepBalance, timestamp)", 
            "", 
            "macro POINTNINE: 900000000000000000", 
            "", 
            "# Call when a user who hasn't reported for a while [and had their rep active] and wants to start again and needs to catch up on penalizations", 
            "# Errors:", 
            "    # -1: not in first half of reporting period", 
            "    # -2: doesn't need to be penalized/caught up", 
            "    # -3: user isn't behind or reported in the last period [and should thus use the penalization functions in consensus.se]", 
            "def penalizationCatchup(branch, sender):", 
            "    refund()", 
            "    # find delta between this last period and the last one a reporter was penalized up to", 
            "    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    oldRep = REPORTING.getRepBalance(branch, sender)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then", 
            "    if(residual > periodLength/2):", 
            "        return(-1)", 
            "    if(delta <= 0):", 
            "        return(-2)", 
            "    # provided user is at least one period behind and they didn't report in the last period", 
            "    if(lastPeriodPenalized==lastPeriod or EXPEVENTS.getNumReportsActual(branch, lastPeriod, sender)):", 
            "        return(-3)", 
            "    # dock 10% for each period they didn't penalize on", 
            "    smoothedRep = oldRep*POINTNINE/ONE", 
            "    i = 1", 
            "    # if delta >22, max is 23 [1 above, 1 below, and 21 in while loop] penalizations simply so we don't run into out of gas issues", 
            "    if(delta>22):", 
            "        smoothedRep = smoothedRep*POINTNINE/ONE", 
            "        delta = 22", 
            "    while i < delta:", 
            "        smoothedRep = smoothedRep*POINTNINE/ONE", 
            "        i += 1", 
            "    # and send it to branch for penalty rep collection", 
            "    repChange = oldRep - smoothedRep", 
            "    # removes rep from reporter who lost it", 
            "    REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, sender), repChange)", 
            "    # sends that rep to the branch rep pool", 
            "    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), repChange)", 
            "    CONSENSUS.setPenalizedUpTo(branch, sender, lastPeriod)", 
            "    log(type=penalizationCaughtUp, branch, sender, lastPeriodPenalized, lastPeriod, repChange, smoothedRep, block.timestamp)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizationCatchup(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "penalizedFrom", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "penalizedUpTo", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "repLost", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "newRepBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizationCaughtUp(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern penalizationCatchup: [penalizationCatchup:[int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "penalizeNotEnoughReports": {
        "address": "0x8c19616de17acdfbc933b99d9f529a689d22098f", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern reportingThreshold: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getEventCanReportOn:[int256,int256,int256,int256]:int256, getEventsToReportOn:[int256,int256,int256,int256]:int256[], setReportingThreshold:[int256]:int256, test_callstack:[]:int256]", 
            "THRESHOLD = 0x5f67ab9ff79be97b27ac8f26ef9f4b429b82e2df", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256, test_callstack:[]:int256]", 
            "FXP = 0xe5b327630cfa7f4b2324f9066c897dceecfd88a3", 
            "inset('refund.se')", 
            "", 
            "macro ONEPOINTTWO: 1200000000000000000", 
            "", 
            "macro POINTZEROZEROONE: 1000000000000000", 
            "", 
            "macro POINTONE: 100000000000000000", 
            "", 
            "macro POINTNINE: 900000000000000000", 
            "", 
            "# Prove both that a reporter voted on less than he/she actually could have and it was <.5 of what they should have reported on using an example event", 
            "# The rep lost here is then sent to the branch's rep account and distributed like other redistributed rep.", 
            "# Note:", 
            "    # Reporters pay an eth bond for this on their first report --- if never called then during collect fees they get it back else it goes back to pay someone who correctly calls this function, so the bond is returned to the poster if not enough penalized is 0 or BRANCHES.getForkPeriod(branch)+1 == lastPeriod during collect fees [which means it's the first period after a fork is initiated]", 
            "# Returns 1 if successful penalization", 
            "# Returns 2 if didn't need to be penalized and thus wasn't", 
            "# Errors:", 
            "    # -1: already done", 
            "    # -2: not in right part of period", 
            "def proveReporterDidntReportEnough(branch, reporter, eventExample):", 
            "    refund()", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(CONSENSUS.getNotEnoughPenalized(branch, reporter, lastPeriod)):", 
            "        return(-1)", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    # in period just after fork period no reports required", 
            "    if(BRANCHES.getForkPeriod(branch)+1 == lastPeriod):", 
            "        CONSENSUS.setNotEnoughPenalized(branch, reporter, lastPeriod)", 
            "        return(2)", 
            "    # events a user should be reporting on", 
            "    # eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))", 
            "    # a^b=exp(b*ln(a))=e^(b*ln(a)).", 
            "    prelim = EXPEVENTS.getNumEventsToReportOn(branch, lastPeriod)", 
            "    # need to do active rep on a period by period basis.. todo", 
            "    exp = FXP.fx_exp(ONEPOINTTWO*FXP.fx_log(EXPEVENTS.getBeforeRep(branch, lastPeriod, sender))/ONE)*ONE/FXP.fx_exp(ONEPOINTTWO*FXP.fx_log(REPORTING.getActiveRep(branch))/ONE)", 
            "    baseReporters = CONSENSUS.getBaseReportersLastPeriod(branch)", 
            "    # if total [which is mult by num events to report on via the prelim amount] is too high [>1] then numevents will estimate a higher number than reality, so need to correct for this below", 
            "    total = exp*baseReporters", 
            "    numEvents = exp*prelim + EXPEVENTS.getNumRequired(branch, lastPeriod)*ONE", 
            "    eventsInPeriod = EXPEVENTS.getNumberEvents(branch, lastPeriod)-EXPEVENTS.getNumRemoved(branch, lastPeriod)", 
            "    if(repConstant >= POINTZEROONE):", 
            "        minimum = min(30+EXPEVENTS.getNumRequired(branch, lastPeriod), eventsInPeriod)", 
            "        if(numEvents/ONE < minimum):", 
            "            numEvents = minimum*ONE", 
            "    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)", 
            "    if(total > ONE):", 
            "        numEvents = (EXPEVENTS.getNumEventsToReportOn(branch, lastPeriod)/baseReporters)*ONE + EXPEVENTS.getNumRequired(branch, lastPeriod)*ONE", 
            "    numReportsActual = EXPEVENTS.getNumReportsActual(branch, lastPeriod, reporter)", 
            "    # reporter couldve reported on event example but didnt", 
            "    couldveReported = THRESHOLD.getEventCanReportOn(branch, lastPeriod, reporter, eventExample)", 
            "    if(numEvents/2 > numReportsActual*ONE && couldveReported):", 
            "        # typically meant for people who did report but not enough [those who didnt at all use pen. catchup] so using before rep is fine, but if not use rep balance", 
            "        originalRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, reporter)", 
            "        if(originalRep==0):", 
            "            originalRep = REPORTING.getRepBalance(branch, reporter)", 
            "        # penalize people", 
            "        newRep = POINTONE*numReportsActual*originalRep / numEvents", 
            "        oldRep = originalRep*POINTNINE / ONE", 
            "        repChange = (oldRep+newRep) - originalRep", 
            "        if(repChange > 0):", 
            "            return(1)", 
            "        # removes rep from reporter who lost it", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, reporter), repChange)", 
            "        # sends that rep to the branch rep pool", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -repChange)", 
            "        EXPEVENTS.setBeforeRep(branch, lastPeriod, oldRep+newRep, reporter)", 
            "        afterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, reporter)", 
            "        newAfterRep = afterRep + repChange", 
            "        if(afterRep==0):", 
            "            newAfterRep = oldRep+newRep", 
            "        # todo decrease denominator by rep person lost here", 
            "        EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, reporter)", 
            "        CONSENSUS.setNotEnoughPenalized(branch, reporter, lastPeriod)", 
            "        CONSENSUS.doRefund(msg.sender, reporter)", 
            "        return(1)", 
            "    else:", 
            "        return(2)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventExample", 
                        "type": "int256"
                    }
                ], 
                "name": "proveReporterDidntReportEnough(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern penalizeNotEnoughReports: [proveReporterDidntReportEnough:[int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "proportionCorrect": {
        "address": "0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
        "code": [
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "", 
            "inset('refund.se')", 
            "", 
            "# Returns the proportion of reporters who reported correctly on a given binary event", 
            "# Returns 0 if no outcome", 
            "def proportionCorrect(event):", 
            "    refund()", 
            "    p = 0", 
            "    outcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    if(outcome==0):", 
            "        return(0)", 
            "    # binary", 
            "    if(EVENTS.getNumOutcomes(event)==2 and EVENTS.getMaxValue(event)==TWO and EVENTS.getMinValue(event)==ONE):", 
            "        # subtract 1 to get it from 0 to 1", 
            "        avgOutcome = EVENTS.getUncaughtOutcome(event) - ONE", 
            "        # say we have outcome of 0, avg is .4, what is p?", 
            "            # p is .6 or 60%", 
            "        if(outcome == ONE):", 
            "            p = ONE - avgOutcome", 
            "        # say we have outcome of 1, avg is .8, what is p (proportion correct)?", 
            "            # p is .8 or 80%", 
            "        elif(outcome == 2 * ONE):", 
            "            p = avgOutcome", 
            "        # unneeded but nice to know that in indeterminate case it'll return 0", 
            "        #elif(outcome == 3 * ONEHALF):", 
            "        #    return(0)", 
            "    return(p)", 
            "", 
            "### Helper functions:", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "proportionCorrect(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern proportionCorrect: [proportionCorrect:[int256]:int256, test_callstack:[]:int256]"
    }, 
    "register": {
        "address": "0xa34c9f6fc047cea795f69b34a063d32e6cb6288c", 
        "code": [
            "inset('refund.se')", 
            "", 
            "event registration(sender: indexed, timestamp)", 
            "", 
            "def register():", 
            "    refund()", 
            "    log(type=registration, msg.sender, block.timestamp)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [], 
                "name": "register()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "registration(int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern refund.se: [register:[]:int256, test_callstack:[]:int256]"
    }, 
    "reporting": {
        "address": "0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "inset('refund.se')", 
            "", 
            "# Storage of all data associated with reporters", 
            "    # Reporting index is the branchID", 
            "    # Reporters index is the rep. address", 
            "    # We 0 index reputation so can walk thru for consensus - todo / wrong don't need 0 indexing anymore", 
            "    # RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key", 
            "    # total rep is all the rep in augur", 
            "    # active rep is the amount which is actually active", 
            "    # fork is the child branch of a parent which forked", 
            "    # dormant rep stores dormant rep values", 
            "data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)", 
            "", 
            "data whitelists[](addresses[], taken)", 
            "", 
            "def init():", 
            "    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0", 
            "    self.Reporting[1010101].reputation[0].repValue = 0", 
            "    self.Reporting[1010101].reputation[0].reporterID = msg.sender", 
            "    self.Reporting[1010101].numberReporters = 2", 
            "    self.Reporting[1010101].repIDtoIndex[1010101] = 1", 
            "    self.Reporting[1010101].reputation[1].repValue = 0", 
            "    self.Reporting[1010101].reputation[1].reporterID = 1010101", 
            "", 
            "def checkWhitelist(address):", 
            "    refund()", 
            "    return(self.whitelists[msg.sender].addresses[address])", 
            "", 
            "def getActiveRep(branch):", 
            "    return(self.Reporting[branch].activeRep)", 
            "", 
            "def adjustActiveRep(branch, amount):", 
            "    self.Reporting[branch].activeRep += amount", 
            "    return(1)", 
            "", 
            "def setFork(branch):", 
            "    self.Reporting[branch].fork = branch", 
            "    return(1)", 
            "", 
            "def getFork(branch):", 
            "    return(self.Reporting[branch].fork)", 
            "", 
            "def checkContractWhitelist(contract, address):", 
            "    refund()", 
            "    return(self.whitelists[contract].addresses[address])", 
            "", 
            "def setWhitelist(contract, addresses:arr):", 
            "    refund()", 
            "    if self.whitelists[contract].taken:", 
            "        return(text(\"ERROR: you have to vote to change a whitelist\"):str)", 
            "    else:", 
            "        self.whitelists[contract].taken = 1", 
            "        i = 0", 
            "        l = len(addresses)", 
            "        while i <l:", 
            "            address = addresses[i]", 
            "            self.whitelists[contract].addresses[addresses] = 1", 
            "            i += 1", 
            "        return(text(\"SUCCESS\"):str)", 
            "", 
            "# @return reputation value", 
            "def getRepByIndex(branch, repIndex):", 
            "    refund()", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getRepBalance(branch, address):", 
            "    refund()", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "def getDormantRepByIndex(branch, repIndex):", 
            "    refund()", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "# getDormantRepBalance", 
            "def balanceOf(branch, address):", 
            "    refund()", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "# return total supply of dormant rep", 
            "def totalSupply(branch):", 
            "    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))", 
            "", 
            "def getReporterID(branch, index):", 
            "    refund()", 
            "    return(self.Reporting[branch].reputation[index].reporterID)", 
            "", 
            "def getTotalRep(branch):", 
            "    refund()", 
            "    return(self.Reporting[branch].totalRep)", 
            "", 
            "# will return 0s for array values after it's looped through all the ones you", 
            "# have an actual balance in", 
            "def getReputation(address):", 
            "    refund()", 
            "    branchListCount = BRANCHES.getNumBranches()", 
            "    if(address):", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    else:", 
            "        address = msg.sender", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumberReporters(branch):", 
            "    refund()", 
            "    return(self.Reporting[branch].numberReporters)", 
            "", 
            "def repIDToIndex(branch, repID):", 
            "    refund()", 
            "    return(self.Reporting[branch].repIDtoIndex[repID])", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setInitialReporters(parent, branchID):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add branch as a \"reporter\"", 
            "    self.Reporting[branchID].numberReporters = 1", 
            "    self.Reporting[branchID].repIDtoIndex[branchID] = 0", 
            "    self.Reporting[branchID].reputation[0].repValue = 0", 
            "    self.Reporting[branchID].reputation[0].reporterID = branchID", 
            "    return(1)", 
            "", 
            "def addReporter(branch, sender, amount, dormant, repToBonderOrBranch):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    refund()", 
            "    reporterIndex = self.Reporting[branch].numberReporters", 
            "    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex", 
            "    self.Reporting[branch].reputation[reporterIndex].repValue = amount", 
            "    self.Reporting[branch].reputation[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].dormantRep[reporterIndex].repValue = dormant", 
            "    self.Reporting[branch].activeRep += amount + repToBonderOrBranch", 
            "    self.Reporting[branch].totalRep += amount + dormant + repToBonderOrBranch", 
            "    self.Reporting[branch].numberReporters += 1", 
            "    return(1)", 
            "", 
            "def addRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue -= value", 
            "    return(1)", 
            "", 
            "def setRep(branch, index, newRep):", 
            "    refund()", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    oldRep = self.Reporting[branch].reputation[index].repValue", 
            "    self.Reporting[branch].reputation[index].repValue = newRep", 
            "    self.Reporting[branch].activeRep += newRep - oldRep", 
            "    self.Reporting[branch].totalRep += newRep - oldRep", 
            "    return(1)", 
            "", 
            "def addDormantRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractDormantRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue -= value", 
            "    return(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "# Sets the initial distribution of rep", 
            "def setSaleDistribution(addresses: arr, balances: arr, branchID):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    i = 0", 
            "    while i < len(addresses):", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]", 
            "        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters", 
            "        self.Reporting[branchID].numberReporters += 1", 
            "        i+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "dormant", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repToBonderOrBranch", 
                        "type": "int256"
                    }
                ], 
                "name": "addReporter(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "adjustActiveRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balanceOf(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkContractWhitelist(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkWhitelist(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getActiveRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getDormantRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getFork(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getReputation(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repID", 
                        "type": "int256"
                    }
                ], 
                "name": "repIDToIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setFork(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newRep", 
                        "type": "int256"
                    }
                ], 
                "name": "setRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "balances", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setSaleDistribution(int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWhitelist(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "totalSupply(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]"
    }, 
    "reportingThreshold": {
        "address": "0x5f67ab9ff79be97b27ac8f26ef9f4b429b82e2df", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256, test_callstack:[]:int256]", 
            "FXP = 0xe5b327630cfa7f4b2324f9066c897dceecfd88a3", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "inset('refund.se')", 
            "", 
            "macro ONEPOINTTWO: 1200000000000000000", 
            "macro POINTZEROONE: 10000000000000000", 
            "macro MAX_THRESHOLD: 10^54", 
            "", 
            "### Helper functions:", 
            "# calculates how many reports should be on a given event", 
            "# todo make sure max cost is actually 500k gas here", 
            "def calculateReportTargetForEvent(branch, eventID, votePeriod, sender):", 
            "    numMarkets = EVENTS.getNumMarkets(eventID)", 
            "    if(numMarkets>25):", 
            "        numMarkets = 25", 
            "    markets = array(numMarkets)", 
            "    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)", 
            "    totalFees = 0", 
            "    shareValue = 0", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        shareValue += MARKETS.getSharesValue(markets[i])", 
            "        totalFees += MARKETS.getFees(markets[i])", 
            "        i += 1", 
            "    totalVal = EXPEVENTS.getShareValue(branch, votePeriod)", 
            "    shareFraction = shareValue*ONE/totalVal", 
            "    numReportersOnMarket = BRANCHES.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))", 
            "    totalFeesInWei = totalFees", 
            "    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)", 
            "    lesser = min(canPayForThisManyReporters*ONE, numReportersOnMarket)", 
            "    if(EXPEVENTS.getLesserReportNum(branch, period, event)==0):", 
            "        EXPEVENTS.refundCost(sender, EXPEVENTS.getSubsidy(branch, votePeriod, eventID))", 
            "        EXPEVENTS.setLesserReportNum(branch, votePeriod, eventID, lesser)", 
            "    return(lesser)", 
            "", 
            "# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))", 
            "    # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == (reporterList[n]/totalRep)**1.2", 
            "    # a^b=exp(b*ln(a))=e^(b*ln(a)).", 
            "def calculateReportingThreshold(branch, eventID, votePeriod, sender):", 
            "    repConstant = EXPEVENTS.getPeriodRepConstant(branch, votePeriod, sender)", 
            "    if(repConstant==0):", 
            "        repConstant = FXP.fx_exp(ONEPOINTTWO*FXP.fx_log(REPORTING.getRepBalance(branch, sender))/ONE)*ONE/FXP.fx_exp(ONEPOINTTWO*FXP.fx_log(REPORTING.getActiveRep(branch))/ONE)", 
            "        numEventsToReportOn = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)", 
            "        expectedEventsForReporter = repConstant * numEventsToReportOn", 
            "        total = expectedEventsForReporter", 
            "        eventsInPeriod = EXPEVENTS.getNumberEvents(branch, expDateIndex)-EXPEVENTS.getNumRemoved(branch, votePeriod)", 
            "        numRequiredEvents = EXPEVENTS.getNumRequired(branch, votePeriod)", 
            "        if(repFraction >= POINTZEROONE):", 
            "            minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)", 
            "            if(total/ONE < minimum):", 
            "                total = minimum*ONE", 
            "                repConstant = total / numEventsToReportOn", 
            "        EXPEVENTS.setPeriodRepConstant(branch, votePeriod, sender, repConstant)", 
            "    # 1 is 10**54 here, lesserreportnum, repconstant, and one are all base 10**18", 
            "    reportingThreshold = EXPEVENTS.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE", 
            "    return(reportingThreshold)", 
            "", 
            "# remove all your calls to calculateReportTarget and calculateReportingThreshold", 
            "# this is a function that gets all the events to report on automatically", 
            "def getEventsToReportOn(branch, period, sender, start):", 
            "    numEvents = EXPEVENTS.getNumberEvents(branch, period)", 
            "    events = array(numEvents)", 
            "    i = 0", 
            "    numEventsToReportOn = 0", 
            "    while i < numEvents:", 
            "        thisEvent = EXPEVENTS.getEvent(branch, period, start + i)", 
            "        if thisEvent != 0:", 
            "            # calculate report target for event here if not done for purposes of computing this", 
            "            if(EXPEVENTS.getLesserReportNum(branch, period, thisEvent)==0):", 
            "                self.calculateReportTargetForEvent(branch, thisEvent, period, msg.sender)", 
            "            reportingThreshold = self.calculateReportingThreshold(branch, thisEvent, period, sender)", 
            "            shaHash = sha3(sender + thisEvent)", 
            "            shaHash = abs(shaHash) / 115792089237316195423571", 
            "            if((shaHash < reportingThreshold || EXPEVENTS.getRequired(thisEvent)) && !EVENTS.getOutcome(thisEvent)):", 
            "                events[numEventsToReportOn] = thisEvent", 
            "                numEventsToReportOn += 1", 
            "        i += 1", 
            "    return(slice(events, items=0, items=numEventsToReportOn): arr)", 
            "", 
            "def getEventCanReportOn(branch, expDateIndex, reporter, event):", 
            "    refund()", 
            "    reportingThreshold = self.calculateReportingThreshold(branch, event, expDateIndex, reporter)", 
            "    shaHash = sha3(reporter + event)", 
            "    shaHash = abs(shaHash) / 115792089237316195423571", 
            "    if(shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(event) || EXPEVENTS.getRequired(events)):", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.", 
            "def setReportingThreshold(event):", 
            "    refund()", 
            "    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)", 
            "    # final check is if no reports on event", 
            "    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one", 
            "    branch = EVENTS.getBranch(event)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(votePeriod==EVENTS.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and !EVENTS.getUncaughtOutcome(event)):", 
            "        EVENTS.setThreshold(event, MAX_THRESHOLD)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "calculateReportTargetForEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "calculateReportingThreshold(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventCanReportOn(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "start", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventsToReportOn(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern reportingThreshold: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getEventCanReportOn:[int256,int256,int256,int256]:int256, getEventsToReportOn:[int256,int256,int256,int256]:int256[], setReportingThreshold:[int256]:int256, test_callstack:[]:int256]"
    }, 
    "roundTwo": {
        "address": "0x7d4b581a0868204b7481c316b430a97fd292a2fb", 
        "code": [
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPIRING = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern sendReputation: [allowance:[int256,int256]:int256, approve:[int256,int256,int256]:int256, convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendReputation:[int256,int256,int256]:int256, test_callstack:[]:int256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]", 
            "SENDREP = 0x9308cf21b5a11f182f9707ca284bbb71bb84f893", 
            "inset('refund.se')", 
            "", 
            "macro POINTZEROONE: 10000000000000000", 
            "", 
            "macro MINBOND: 200*ONE", 
            "", 
            "# Allows a user to post a bond to enter round two of consensus", 
            "# Appeal_Bond = Market_Value * (0.01 + Market_Fee / 2) + Average_Adjudication_Cost", 
            "    # Average_Adjudication_Cost = Total fees paid to reporters for all markets in this reporting round / number of markets in this reporting round.", 
            "        # needs an abs min of ~200 rep.", 
            "# Reporting period is 2 months minus 48 hours.  This 48 hours allows for the appeals to take place before the next reporting round begins.", 
            "# Returns 1 upon success", 
            "# Errors:", 
            "    #  0: invalid votePeriod/branch", 
            "    # -1: Pushed forward event, bonding not allowed during this", 
            "    # -2: branch is in the middle of a fork", 
            "    # -3: not enough rep to cover bond", 
            "def roundTwoPostBond(branch, event, eventIndex, votePeriod):", 
            "    refund()", 
            "    if(BRANCHES.getVotePeriod(branch)!=votePeriod):", 
            "        return(0)", 
            "    # if pushed forward don't allow until no longer pushed fwd", 
            "    if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event)):", 
            "        return(-1)", 
            "    market = EVENTS.getMarket(event, 0)", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    if(forkPeriod == votePeriod or (forkPeriod+1) == votePeriod):", 
            "        return(-2)", 
            "    # todo find actual cost", 
            "    if(msg.value < 500000*tx.gasprice):", 
            "        return(0)", 
            "    # pays money to cover resolution cost", 
            "    send(BACKSTOPS, msg.value)", 
            "    BACKSTOPS.setRoundTwoRefund(event, msg.value)", 
            "    avgAdjCost = BRANCHES.getInitialBalance(branch, votePeriod)/EXPIRING.getNumberEvents(branch, votePeriod)", 
            "    bond = avgAdjCost + MARKETS.getSharesValue(market)*(POINTZEROONE + MARKETS.getTradingFee(market)/2) / ONE", 
            "    bond = min(bond, MINBOND)", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    # if so, we're in the final 48 hours and event is in this branch + votePeriod", 
            "    if(!resolving && block.timestamp/BRANCHES.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/BRANCHES.getPeriodLength(branch)) && eventID!=0 && event==eventID && BACKSTOPS.getRoundTwo(event)==0 && EVENTS.getForked(event)==0):", 
            "        # send the bond to the branch", 
            "        if(SENDREP.sendReputation(branch, event, bond)==0):", 
            "            return(-3)", 
            "        period = BRANCHES.getVotePeriod(branch)", 
            "        # remove from events in # to report on calc for last period", 
            "        EXPIRING.removeEvent(branch, period)", 
            "        # makes event required reporting in round 2 (the next period) as well", 
            "        EXPIRING.setEventRequired(branch, period+1, event)", 
            "        # push event into next period", 
            "        EXPIRING.addEvent(branch, period+1, event)", 
            "        # set event expiration date to be after the current reporting period ends", 
            "        EVENTS.setExpiration(event, block.timestamp)", 
            "        # set round two to true so can't be done again", 
            "        BACKSTOPS.setRoundTwo(event, 1)", 
            "        BACKSTOPS.setOriginalVotePeriod(event, votePeriod)", 
            "        if(scalar(event) or categorical(event)):", 
            "            BACKSTOPS.setOriginalOutcome(event, EVENTS.getUncaughtOutcome(event))", 
            "        else:", 
            "            BACKSTOPS.setOriginalOutcome(event, catch(EVENTS.getUncaughtOutcome(event)))", 
            "        BACKSTOPS.setOriginalEthicality(event, ethic_catch(EVENTS.getEthical(event)))", 
            "        EXPEVENTS.addRoundTwo(branch, period)", 
            "        BACKSTOPS.setBondPoster(event, msg.sender)", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        EVENTS.setmode(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        return(1)", 
            "", 
            "# Resolves a round 2 event scenario", 
            "# Errors:", 
            "    # 0: returned if not reported on again yet", 
            "def roundTwoResolve(branch, event, eventIndex, sender):", 
            "    refund()", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    market = EVENTS.getMarket(event, 0)", 
            "    avgAdjCost = BRANCHES.getInitialBalance(branch, votePeriod-1)/EXPEVENTS.getNumberEvents(branch, votePeriod-1)", 
            "    bond = avgAdjCost + MARKETS.getSharesValue(market)*(POINTZEROONE + MARKETS.getTradingFee(market)/2) / ONE", 
            "    bond = min(bond, MINBOND)", 
            "    votedOnAgain = 0", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    overruled = 1", 
            "    # checks if the event's outcome was overruled or the same as the original reporting cycle", 
            "    if(scalar(event) or categorical(event)):", 
            "        if(BACKSTOPS.getOriginalOutcome(event) == EVENTS.getUncaughtOutcome(event) && BACKSTOPS.getOriginalEthicality(event)==ethic_catch(EVENTS.getEthical(event))):", 
            "            overruled = 0", 
            "    elif(BACKSTOPS.getOriginalOutcome(event) == catch(EVENTS.getUncaughtOutcome(event)) && BACKSTOPS.getOriginalEthicality(event)==ethic_catch(EVENTS.getEthical(event))):", 
            "        overruled = 0", 
            "    if(votePeriod > (EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch))):", 
            "        votedOnAgain = 1", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    # if forking and this isn't the fork event", 
            "    if(forkPeriod==votePeriod or votePeriod==(forkPeriod+1) && (BRANCHES.getEventForkedOver(branch)!=event && BACKSTOPS.getBondReturned(event)==0 && BACKSTOPS.getRoundTwo(event))):", 
            "        # return the bond", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)", 
            "        BACKSTOPS.setBondReturned(event)", 
            "        BACKSTOPS.setRoundTwo(event, 0)", 
            "        BACKSTOPS.doRoundTwoRefund(sender, event)", 
            "        return(1)", 
            "    # overruled and bond poster was right", 
            "    elif(overruled && votedOnAgain && BACKSTOPS.getRoundTwo(event) && votePeriod!=BACKSTOPS.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !BACKSTOPS.getBondReturned(event)):", 
            "        # return the bond", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)", 
            "        # and set final outcome / event bond, etc", 
            "        self.resolve(branch, event)", 
            "        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rep redistribution for the round 2 reporting", 
            "        BACKSTOPS.setFinal(event)", 
            "        BACKSTOPS.setBondReturned(event)", 
            "        BACKSTOPS.doRoundTwoRefund(sender, event)", 
            "        return(2*bond)", 
            "    # same as original consensus and bond poster was wrong [or malicious]", 
            "    elif(votedOnAgain && BACKSTOPS.getRoundTwo(event) && votePeriod!=BACKSTOPS.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !BACKSTOPS.getBondReturned(event)):", 
            "        # lose bond", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), bond)", 
            "        # and set final outcome / event bond, etc", 
            "        self.resolve(branch, event)", 
            "        # rep redistribution from original period/orig. outcome stands, rep redistribution from round 2 happens as usual as well", 
            "        BACKSTOPS.setFinal(event)", 
            "        BACKSTOPS.setBondReturned(event)", 
            "        BACKSTOPS.doRoundTwoRefund(sender, event)", 
            "        return(1)", 
            "    # not voted on again yet", 
            "    else:", 
            "        return(0)", 
            "", 
            "### Helper functions", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==2**6Z)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "# Actually sets the outcome for a round 2 event", 
            "# Errors:", 
            "    # 0: event isn't binary, categorical, or scalar [hell has frozen over or quantum events have been invented]", 
            "def resolve(branch, event):", 
            "    refund()", 
            "    bond = EVENTS.getBond(event)", 
            "    # set ethicality to the binned version of the ethics", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    EVENTS.setEthics(event, ethical)", 
            "    # binary", 
            "    if(binary(event)):", 
            "        # set outcome to the binned version of the outcome", 
            "        fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        if(fxpOutcome==3*ONEHALF || !ethical):", 
            "            # give event bond money to reporters", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(branch, bond)", 
            "            # not ethical is same as 1.5 outcome w/ binary", 
            "            fxpOutcome = 3*ONEHALF", 
            "            EVENTS.setOutcome(event, fxpOutcome)", 
            "        else:", 
            "            # return bond", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(INFO.getCreator(event), bond)", 
            "        return(1)", 
            "    # scalar", 
            "    elif(scalar(event) or categorical(event)):", 
            "        mode = EVENTS.getUncaughtOutcome(event)", 
            "        # sets mode which is used to penalize/reward reporters", 
            "        EVENTS.setmode(event, mode)", 
            "        scaled_max = EVENTS.getMaxValue(event)", 
            "        scaled_min = EVENTS.getMinValue(event)", 
            "        if(categorical(event)):", 
            "            scaled_min = ONE", 
            "            scaled_max = ONE*EVENTS.getNumOutcomes(event)", 
            "        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min", 
            "        # sets outcome which is used in calculating payouts", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        ethicOutcome = ONEHALF * (scaled_max - scaled_min)/ONE + scaled_min", 
            "        if(mode==ONEHALF || !ethical):", 
            "            # give event bond money to reporters", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(branch, bond)", 
            "            # not ethical is same as .5 outcome w/ scalar", 
            "            # mode is used to compare for reporting acc. so still the same as reported outcome, but resolving the market as .5", 
            "            EVENTS.setOutcome(event, ethicOutcome)", 
            "        else:", 
            "            # return bond", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(INFO.getCreator(event), bond)", 
            "        return(1)", 
            "    # (should never be reached)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "resolve(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "roundTwoPostBond(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "roundTwoResolve(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern roundTwo: [resolve:[int256,int256]:int256, roundTwoPostBond:[int256,int256,int256,int256]:int256, roundTwoResolve:[int256,int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "roundTwoPenalize": {
        "address": "0xcd6c7bc634257f82903b182142aae7156d72a200", 
        "code": [
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern proportionCorrect: [proportionCorrect:[int256]:int256, test_callstack:[]:int256]", 
            "PROPORTION = 0x0fbddb6bfb81c8d0965a894567cf4061446072c2", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, test_callstack:[]:int256]", 
            "BACKSTOPS = 0x708fdfe18bf28afe861a69e95419d183ace003eb", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "extern roundTwo: [resolve:[int256,int256]:int256, roundTwoPostBond:[int256,int256,int256,int256]:int256, roundTwoResolve:[int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "ROUNDTWO = 0x7d4b581a0868204b7481c316b430a97fd292a2fb", 
            "", 
            "inset('refund.se')", 
            "", 
            "#event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)", 
            "", 
            "macro POINTZEROONE: 10000000000000000", 
            "macro POINTEIGHT: 800000000000000000", 
            "macro POINTTWO: 200000000000000000", 
            "macro POINTFOUR: 400000000000000000", 
            "macro MINBOND: 200*ONE", 
            "", 
            "# Penalizes a reporter for reporting wrongly on a round 2 reporting / backstop 1 event", 
            "# So we want to do the rep redistribution for both period 1 and period 2 at this time", 
            "# essentially penalizeWrong for backstop 1 [where everyone reports on a given event]", 
            "# in a fork this is called on the original branch and event is reported on again on new branch", 
            "# Errors:", 
            "    #  0: event isn't eligible/up for round two penalization", 
            "    # -2: already past first half of new period and needed to penalize before then", 
            "    # -3: round two resolve wasn't successful", 
            "    # -4: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize", 
            "    # -5: already done for all events in this period", 
            "    # -6: needed to collect fees last period which sets the before/after rep", 
            "# force event to be resolved first if it can be", 
            "# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized", 
            "# todo go over penalty amounts like .2 for ethicality seems too high", 
            "def penalizeRoundTwoWrong(branch, event):", 
            "    refund()", 
            "    roundTwo = BACKSTOPS.getRoundTwo(event)", 
            "    repBalance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    newRep = 0", 
            "    newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)", 
            "    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)", 
            "    if(CONSENSUS.getPenalizedUpTo(branch, msg.sender)==lastPeriod):", 
            "        return(-5)", 
            "    if(!CONSENSUS.getFeesCollected(branch, msg.sender, lastPeriod)):", 
            "        return(-6)", 
            "    elif(BRANCHES.getForkPeriod(branch) == lastPeriod && event!=forkEvent):", 
            "        return(-4)", 
            "    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]", 
            "    uncaught = EVENTS.getUncaughtOutcome(event)", 
            "    if(!uncaught):", 
            "        if(ROUNDTWO.roundTwoResolve(branch, event, EXPEVENTS.getEventIndex(votePeriod, event), msg.sender)==0):", 
            "            return(-3)", 
            "    outcome = catch(uncaught)", 
            "    if(scalar(event) or categorical(event)):", 
            "        outcome = uncaught", 
            "    forkEvent = BRANCHES.getEventForkedOver(branch)", 
            "    p = PROPORTION.proportionCorrect(event)", 
            "    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)", 
            "    lastPenalizationPeriod = lastPeriod - 1", 
            "    oldReport = EXPEVENTS.getReport(branch,lastPenalizationPeriod,event,msg.sender)", 
            "    ethics = EXPEVENTS.getEthicReport(branch, lastPeriod, event, msg.sender)", 
            "    oldEthics = EXPEVENTS.getEthicReport(branch, lastPenalizationPeriod, event, msg.sender)", 
            "    avgAdjCost = BRANCHES.getInitialBalance(branch, votePeriod)/EXPIRING.getNumberEvents(branch, votePeriod)", 
            "    bond = avgAdjCost + MARKETS.getSharesValue(market)*(POINTZEROONE + MARKETS.getTradingFee(market)/2) / ONE", 
            "    bond = min(bond, MINBOND)", 
            "    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period", 
            "    elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):", 
            "        return(-2)", 
            "    # if overruled / different outcome after reporting on again", 
            "    overruled = 0", 
            "    if(scalar(event) or categorical(event)):", 
            "        if((BACKSTOPS.getOriginalOutcome(event) != EVENTS.getUncaughtOutcome(event) or BACKSTOPS.getOriginalEthicality(event)!=ethic_catch(EVENTS.getEthical(event)))):", 
            "            overruled = 1", 
            "    elif((BACKSTOPS.getOriginalOutcome(event) != catch(EVENTS.getUncaughtOutcome(event)) or BACKSTOPS.getOriginalEthicality(event)!=ethic_catch(EVENTS.getEthical(event)))):", 
            "        overruled = 1", 
            "", 
            "    numReportedOn = EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)", 
            "", 
            "    # penalization on a round 2 event if not already penalized, it has outcome, and user reported on it", 
            "    # if it's penalizing in the period it was pushed back to we can do the penalization, should do it for both the first and second period", 
            "    if(BACKSTOPS.getRoundTwo(event) && (BACKSTOPS.getFinal(event) or event==forkEvent) && !CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event) && (reportValue or oldReport)):", 
            "        newAfterRep = 0", 
            "        smoothedRep = 0", 
            "        # Do the first rep redistribution based on first report and final outcome if reported first time", 
            "        if(oldReport && outcome!=0):", 
            "            # wrong", 
            "            #184467440737095520 == 0.01 in fxp", 
            "            if(oldReport > outcome+POINTZEROONE or oldReport < outcome-POINTZEROONE):", 
            "                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                    diff = oldReport - outcome", 
            "                    p = -(abs(diff)/2) + ONE", 
            "                newRep = oldRep*(2*p - ONE)/ONE", 
            "            # right", 
            "            else:", 
            "                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                    diff = oldReport - outcome", 
            "                    p = -(abs(diff)/2) + ONE", 
            "                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE", 
            "            # (1-k) * old rep + k * new rep where k = 0.4 / (number of events you reported on last period) for penalization and pen. rate for backstop 1", 
            "            # use .04 as a max penalty per event for round 2 liars who lied on first report --- todo should do .02 in the not-overruled case", 
            "            if(numReportedOn<10):", 
            "                repChange = oldRep * (ONE - POINTFOUR/10)/ONE + newRep*(POINTFOUR/10)/ONE - oldRep", 
            "            else:", 
            "                repChange = oldRep * (ONE - POINTFOUR/numReportedOn)/ONE + newRep*(POINTFOUR/numReportedOn)/ONE - oldRep", 
            "            newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange", 
            "            EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "            # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively", 
            "            if(oldEthics != ethic_catch(EVENTS.getEthical(event)) && repChange >=0):", 
            "                repChange = -POINTTWO*repBalance / ONE", 
            "            if(repBalance + repChange <= 0):", 
            "                repChange = -1*repBalance", 
            "            # if overruled: reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usual later in the process", 
            "            if(overruled && BACKSTOPS.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):", 
            "                # done instead of sending to redistrib. pool", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), repChange)", 
            "                # sends that rep to the bonded challenger", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), -repChange)", 
            "                BACKSTOPS.increaseBondPaid(event, (-1*repChange))", 
            "        # Do the second (for each user) based on second report and final outcome", 
            "        if(reportValue && outcome!=0):", 
            "            # wrong", 
            "            #184467440737095520 == 0.01 in fxp", 
            "            if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):", 
            "                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                    diff = reportValue - outcome", 
            "                    p = -(abs(diff)/2) + ONE", 
            "                newRep = oldRep*(2*p - ONE)/ONE", 
            "            # right", 
            "            else:", 
            "                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):", 
            "                    diff = reportValue - outcome", 
            "                    p = -(abs(diff)/2) + ONE", 
            "                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE", 
            "            # (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period) for penalization and pen. rate for backstop 1", 
            "            # use .02 as a max penalty per event for round 2 on second report", 
            "            if(numReportedOn<10):", 
            "                repChange = oldRep * (ONE - POINTTWO/10)/ONE + newRep*(POINTTWO/10)/ONE - oldRep", 
            "            else:", 
            "                repChange = oldRep * (ONE - POINTTWO/numReportedOn)/ONE + newRep*(POINTTWO/numReportedOn)/ONE - oldRep", 
            "            newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange", 
            "            EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "            # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively - or should this only be done for last period?", 
            "            if(ethics != ethic_catch(EVENTS.getEthical(event)) && repChange >=0):", 
            "                repChange = -POINTTWO*repBalance / ONE", 
            "            if(repBalance + repChange <= 0):", 
            "                repChange = -1*repBalance", 
            "            if(overruled && BACKSTOPS.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):", 
            "                # done instead of sending to redistrib. pool", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), repChange)", 
            "                # sends that rep to the bonded challenger", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), -repChange)", 
            "                BACKSTOPS.increaseBondPaid(event, (-1*repChange))", 
            "        CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)", 
            "        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)", 
            "    else:", 
            "        return(0)", 
            "    # if a fork event in original branch, only event needed to report on in this period is that one [b/c the original branch resolves it as a regular round 2 event, fork reports again]", 
            "    if(event==forkEvent):", 
            "        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, (numReportedOn - 1))", 
            "    # penalization on a regular event if not already penalized, it has outcome, and user reported on it", 
            "    if(numReportedOn==CONSENSUS.getPenalizedNum(branch, lastPeriod, msg.sender)):", 
            "        if(newAfterRep <= 0):", 
            "            newAfterRep = 0", 
            "            EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, msg.sender, lastPeriod)", 
            "        CONSENSUS.increaseDenominator(branch, lastPeriod, newAfterRep)", 
            "        totalRepDifference = newAfterRep - oldRep", 
            "        if(repBalance + totalRepDifference <= 0):", 
            "            totalRepDifference = -1*repBalance", 
            "        if(totalRepDifference<0):", 
            "            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]", 
            "            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)", 
            "            # sends that rep to the branch", 
            "            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)", 
            "    return(1)", 
            "", 
            "", 
            "### Helper functions:", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeRoundTwoWrong(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern roundTwoPenalize: [penalizeRoundTwoWrong:[int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "sendReputation": {
        "address": "0x9308cf21b5a11f182f9707ca284bbb71bb84f893", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern makeReports: [makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:_, submitReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "REPORTS = 0x70a893eb9569041e97a3787f0c76a1eb6378d8b2", 
            "extern penalizationCatchup: [penalizationCatchup:[int256,int256]:int256, test_callstack:[]:int256]", 
            "CATCHUP = 0xabe47f122a496a732d6c4b38b3ca376d597d75dd", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "inset('refund.se')", 
            "", 
            "# sender/owner, then spender", 
            "data amountCanSpend[][]", 
            "", 
            "event Transfer(_from:indexed, _to:indexed, _value, timestamp)", 
            "event Approval(_owner:indexed, _spender:indexed, value, timestamp)", 
            "", 
            "# fix sender, tx.origin stuff here", 
            "# todo should we check collect fees done or no", 
            "", 
            "# send active reputation", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "def sendReputation(branch, recver, value):", 
            "    refund()", 
            "    # Rep cannot be simultaneously spent (transferred) and used to vote", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    # you can't trade if you or the person you're sending to have submitted a report, or at all in the second half of the period [b/c you can messup / cheat w/ reporting by gettin extra claims on fees] and you can't trade in the first half of a period until you've been penalized for reporting wrongly/not reporting", 
            "    # use a diff. fun. than getReport here", 
            "    #if(value<=0 || EXPEVENTS.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, recver, 0) != 0):", 
            "    # EXPEVENTS.getNumReportsActual(branch, currentVotePeriod, msg.sender)", 
            "    #    return(0)", 
            "", 
            "    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    if(delta > 1):", 
            "        if(CATCHUP.penalizationCatchup(branch, msg.sender)!=1):", 
            "            return(0)", 
            "", 
            "    # need to check all this for the person it's being sent to as well", 
            "    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):", 
            "        return(0)", 
            "    #if(REPORTS.getRRUpToDate()!=1):", 
            "    #    doIt()", 
            "    #    self.RRDone = true", 
            "    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):", 
            "    #    CONSENSUS.collectFees(lastPeriod)", 
            "    # before rep, after rep, balance", 
            "    # person you're sending to needs rr up to date / done as well", 
            "    # auto increment vote period if needed", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one, only if in first half of period", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, tx.origin, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value && value > 0):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addRep(branch, receiverIndex, value)):", 
            "            log(type=Transfer, msg.sender, recver, value, timestamp)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# Transfer dormant rep", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "# sendDormantRep", 
            "def transfer(branch, recver, value):", 
            "    refund()", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(value<=0):", 
            "        return(0)", 
            "    sender = msg.sender", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=msg.sender):", 
            "        CONSENSUS.setPenalizedUpTo(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.balanceOf(branch, sender)", 
            "    if(senderBalance >= value && value > 0):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, receiverIndex, value)):", 
            "            log(type=Transfer, msg.sender, recver, value, block.timestamp)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# TransferFrom per token api for dormant rep", 
            "# fails unless from has authorized sender", 
            "def transferFrom(branch, from, recver, value):", 
            "    refund()", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(value<=0):", 
            "        return(0)", 
            "    sender = from", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=from):", 
            "        CONSENSUS.setPenalizedUpTo(branch, from, (BRANCHES.getVotePeriod(branch)-1))", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, from, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.balanceOf(branch, sender)", 
            "    if(senderBalance >= value && value > 0 && self.amountCanSpend[from][msg.sender]>=value):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, receiverIndex, value)):", 
            "            self.amountCanSpend[from][msg.sender] -= value", 
            "            log(type=Transfer, from, recver, value, block.timestamp)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# Allows spender to withdraw from your dormant rep account", 
            "def approve(branch, spender, value):", 
            "    self.amountCanSpend[msg.sender][spender] = value", 
            "    log(type=Approval, msg.sender, spender, value, block.timestamp)", 
            "    return(1)", 
            "", 
            "# Returns amount spender can withdraw from owner", 
            "def allowance(owner, spender):", 
            "    return(self.amountCanSpend[owner][spender])", 
            "", 
            "# Convert active rep to dormant rep", 
            "# error messages", 
            "    # -1: not in first half of reporting period", 
            "# shouldn't be penalized for dormant rep when converting back to active due to not reporting beyond the dormant penalization", 
            "# todo when handling dormant rep stuff:", 
            "# if a person reported on a round 2 event, they cannot convert their rep to dormant or send rep until they've finished the resolution process for that round 2 event", 
            "# unless this just happened to them last period and they reported correctly then", 
            "def convertToDormantRep(branch, value):", 
            "    refund()", 
            "    # if not in first half of reporting period", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):", 
            "        return(0)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "      return(-1)", 
            "\t\t# benny comment:", 
            "            #```Maybe still have this sort-of variable \"power\" to it, but REP initially doesn't have \"full-power\", or REP that hasn't been used to report over the past week has now let it's \"power-meter\" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch \"on\" or switch \"off\" the REP. If a user knows, \"I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power\", well that's pretty good incentive to keep the user active, without actually taking it from them.```", 
            "", 
            "    if(value<=0):", 
            "        return(0)", 
            "", 
            "    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    if(delta > 1):", 
            "        if(CATCHUP.penalizationCatchup(branch, msg.sender)!=1):", 
            "            return(0)", 
            "", 
            "    #if(REPORTS.getRRUpToDate()!=1):", 
            "    #    doIt()", 
            "", 
            "    #if(hasReported(lastPeriod) && periodOver):", 
            "        #CONSENSUS.collectFees(lastPeriod)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, tx.origin, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, senderIndex, value)):", 
            "            REPORTING.adjustActiveRep(branch, -value)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# Convert dormant rep to active rep", 
            "# error messages", 
            "    # -1: not in first half of reporting period", 
            "def convertToActiveRep(branch, value):", 
            "    refund()", 
            "    # if not in first half of reporting period", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "      return(-1)", 
            "", 
            "    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    if(delta > 1):", 
            "        if(CATCHUP.penalizationCatchup(branch, msg.sender)!=1):", 
            "            return(0)", 
            "    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):", 
            "        return(0)", 
            "    if(value<=0):", 
            "        return(0)", 
            "", 
            "    #if(REPORTS.getRRUpToDate()):", 
            "        #doIt()", 
            "    #if(hasReported(lastPeriod) && periodOver):", 
            "        #CONSENSUS.collectFees(lastPeriod)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.setPenalizedUpTo(branch, tx.origin, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    senderBalance = REPORTING.balanceOf(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addRep(branch, senderIndex, value)):", 
            "            REPORTING.adjustActiveRep(branch, value)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "", 
            "macro hasReported($branch, $period):", 
            "    EXPEVENTS.getNumReportsActual($branch, $period, msg.sender)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "owner", 
                        "type": "int256"
                    }, 
                    {
                        "name": "spender", 
                        "type": "int256"
                    }
                ], 
                "name": "allowance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "spender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "approve(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "convertToActiveRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "convertToDormantRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "sendReputation(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "transfer(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "transferFrom(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "_owner", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "_spender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "Approval(int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "_from", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "_to", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "_value", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "Transfer(int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern sendReputation: [allowance:[int256,int256]:int256, approve:[int256,int256,int256]:int256, convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendReputation:[int256,int256,int256]:int256, test_callstack:[]:int256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]"
    }, 
    "slashRep": {
        "address": "0x5069d883e31429c6dd1325d961f443007747c7a2", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, test_callstack:[]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x77c424f86a1b80f1e303d1c2651acd6aba653cb6", 
            "extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "CONSENSUS = 0x4a61f3db785f1e2a23ffefeafaceeef2df551667", 
            "", 
            "inset('refund.se')", 
            "", 
            "event slashedRep(branch: indexed, sender: indexed, reporter: indexed, event, repSlashed, slasherBalance, timestamp)", 
            "", 
            "# Anti cheat/collusion mechanism: provide ballot and random salt to steal rep from a colluder", 
            "# Returns:", 
            "    # 1: on success", 
            "    # -1: invalid vote period", 
            "    # -2: past reveal date", 
            "    # -3: reporter being slashed doesn't exist", 
            "    # -4: invalid claim / report hash -     # make sure that the colluding reporter's commit is the same as the info provided in the params", 
            "def slashRep(branch, salt, report, reporter, eventID):", 
            "    refund()", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    alreadySlashed = CONSENSUS.getSlashed(branch, votePeriod, reporter)", 
            "    votePeriodShouldBe = block.timestamp / periodLength - 1", 
            "    realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, eventID)", 
            "    hashInfo = array(4)", 
            "    hashInfo[0] = reporter", 
            "    hashInfo[1] = salt", 
            "    hashInfo[2] = report", 
            "    hashInfo[3] = eventID", 
            "    reportHash = sha3(hashInfo, chars=32*len(hashInfo))", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    if(votePeriodShouldBe!=votePeriod):", 
            "        return(-1)", 
            "    if(alreadySlashed):", 
            "        return(-5)", 
            "    if(reportHash!=realHash):", 
            "        return(-4)", 
            "    CONSENSUS.setSlashed(branch, votePeriod, reporter)", 
            "    reporterIndex = REPORTING.repIDToIndex(branch, reporter)", 
            "    if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):", 
            "        return(-3)", 
            "    trutherIndex = REPORTING.repIDToIndex(branch, msg.sender)", 
            "    # if the truther's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, trutherIndex)!=msg.sender):", 
            "        trutherIndex = REPORTING.getNumberReporters(branch)", 
            "        REPORTING.addReporter(branch, msg.sender, 0, 0, 0)", 
            "    reporterBalance = REPORTING.getRepBalance(branch, reporter)", 
            "    # removes rep from colluder", 
            "    REPORTING.subtractRep(branch, reporterIndex, reporterBalance)", 
            "    # gives truther half", 
            "    REPORTING.addRep(branch, trutherIndex, (reporterBalance*ONEHALF / ONE))", 
            "    # other half sent to branch", 
            "    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), reporterBalance*ONEHALF/ONE)", 
            "    log(type=slashedRep, branch, msg.sender, reporter, eventID, reporterBalance, REPORTING.getRepBalance(branch, msg.sender), block.timestamp)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "slashRep(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "repSlashed", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "slasherBalance", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }
                ], 
                "name": "slashedRep(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern slashRep: [slashRep:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]"
    }, 
    "topics": {
        "address": "0x8caf2c0ce7cdc2e81b58f74322cefdef440b3f8d", 
        "code": [
            "inset('refund.se')", 
            "", 
            "# Topics[] is indexed by branch ID", 
            "#   numTopics is the number of distinct topics on the branch", 
            "#   topics[] is an array with all distinct topics in this branch", 
            "#   popularity[] is indexed by topic, values are the total \"popularity\" of all markets using the topic.", 
            "#       (Volume is a crude popularity metric which will be refined by testing.)", 
            "# Note: sorting and/or ranking must be done by the client!", 
            "data Topics[](numTopics, topics[], popularity[])", 
            "", 
            "def getTopicsInBranch(branch, offset, numTopicsToLoad):", 
            "    numTopics = self.Topics[branch].numTopics", 
            "    if offset > numTopics or numTopics == 0:", 
            "        return([]: arr)", 
            "    if numTopicsToLoad == 0:", 
            "        numTopicsToLoad = numTopics", 
            "    numTopicsToLoad = min(numTopicsToLoad, numTopics - offset)", 
            "    topicsInBranch = array(numTopicsToLoad)", 
            "    i = 0", 
            "    while i < numTopicsToLoad:", 
            "        topicsInBranch[i] = self.Topics[branch].topics[i + offset]", 
            "        i += 1", 
            "    return(topicsInBranch: arr)", 
            "", 
            "def getTopicsInfo(branch, offset, numTopicsToLoad):", 
            "    numTopics = self.Topics[branch].numTopics", 
            "    if offset > numTopics or numTopics == 0:", 
            "        return([]: arr)", 
            "    if numTopicsToLoad == 0:", 
            "        numTopicsToLoad = numTopics", 
            "    numTopicsToLoad = min(numTopicsToLoad, numTopics - offset)", 
            "    topicsInfo = array(numTopicsToLoad * 2)", 
            "    i = 0", 
            "    j = 0", 
            "    while i < numTopicsToLoad:", 
            "        topic = self.Topics[branch].topics[i + offset]", 
            "        topicsInfo[j] = topic", 
            "        topicsInfo[j + 1] = self.Topics[branch].popularity[topic]", 
            "        i += 1", 
            "        j += 2", 
            "    return(topicsInfo: arr)", 
            "", 
            "# @return fxp", 
            "def getTopicPopularity(branch, topic):", 
            "    return(self.Topics[branch].popularity[topic])", 
            "", 
            "def getNumTopicsInBranch(branch):", 
            "    return(self.Topics[branch].numTopics)", 
            "", 
            "def updateTopicPopularity(branch, topic, fxpAmount):", 
            "    refund()", 
            "    # if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    if self.Topics[branch].popularity[topic] == 0:", 
            "        self.Topics[branch].topics[self.Topics[branch].numTopics] = topic", 
            "        self.Topics[branch].numTopics += 1", 
            "    self.Topics[branch].popularity[topic] += fxpAmount", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumTopicsInBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "topic", 
                        "type": "int256"
                    }
                ], 
                "name": "getTopicPopularity(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numTopicsToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getTopicsInBranch(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numTopicsToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getTopicsInfo(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "topic", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fxpAmount", 
                        "type": "int256"
                    }
                ], 
                "name": "updateTopicPopularity(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [getNumTopicsInBranch:[int256]:int256, getTopicPopularity:[int256,int256]:int256, getTopicsInBranch:[int256,int256,int256]:int256[], getTopicsInfo:[int256,int256,int256]:int256[], test_callstack:[]:int256, updateTopicPopularity:[int256,int256,int256]:int256]"
    }, 
    "trade": {
        "address": "0xd2e9f7c2fd4635199b8cc9e8128fc4d27c693945", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "BRANCHES = 0x482c57abdce592b39434e3f619ffc3db62ab6d01", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256, test_callstack:[]:int256]", 
            "INFO = 0x8a4e2993a9972ee035453bb5674816fc3a698718", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, test_callstack:[]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd19195b9e8a2d8ed14fc3a2823856b5c16f7f55", 
            "extern refund.se: [addFees:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256,int256,int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256, test_callstack:[]:int256]", 
            "MARKETS = 0x60cb05deb51f92ee25ce99f67181ecaeb0b743ea", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256, test_callstack:[]:int256]", 
            "EVENTS = 0x8f2c2267687cb0f047b28a1b6f945da6e101a0d7", 
            "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getBestAskID:[int256,int256]:int256, getBestBidID:[int256,int256]:int256, getID:[int256]:int256, getSender:[]:int256, getTradeOwner:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], get_trade_block:[int256]:int256, makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]", 
            "TRADES = 0xd70c6e1f3857d23bd96c3e4d2ec346fa7c3931f3", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256]", 
            "EXPEVENTS = 0xe4714fcbdcdba49629bc408183ef40d120700b8d", 
            "extern refund.se: [getNumTopicsInBranch:[int256]:int256, getTopicPopularity:[int256,int256]:int256, getTopicsInBranch:[int256,int256,int256]:int256[], getTopicsInfo:[int256,int256,int256]:int256[], test_callstack:[]:int256, updateTopicPopularity:[int256,int256,int256]:int256]", 
            "TOPICS = 0x8caf2c0ce7cdc2e81b58f74322cefdef440b3f8d", 
            "inset('refund.se')", 
            "inset('logReturn.se')", 
            "", 
            "event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome, timestamp, takerFee, makerFee, onChainPrice, tradeHash, tradeGroupID)", 
            "event log_short_fill_tx(market:indexed, sender:indexed, owner:indexed, price, amount, tradeid, outcome, timestamp, takerFee, makerFee, numOutcomes, onChainPrice, tradeHash, tradeGroupID)", 
            "event trade_logReturn(returnValue)", 
            "event trade_logArrayReturn(returnArray: arr)", 
            "", 
            "macro logArrayReturn($a):", 
            "    log(type=trade_logArrayReturn, $a)", 
            "    return($a: arr)", 
            "", 
            "macro MINIMUM_TRADE_SIZE: 10000000000", 
            "macro ONEPOINTFIVE: 1500000000000000000", 
            "# Trade types", 
            "macro BID: 1", 
            "macro ASK: 2", 
            "# Field counts", 
            "macro TRADE_FIELDS: 8", 
            "# Boolean success/failure", 
            "macro SUCCESS: 1", 
            "# Error codes", 
            "macro INSUFFICIENT_BALANCE: 10", 
            "macro TRADE_SAME_BLOCK_PROHIBITED: 22", 
            "", 
            "# calculates trading fee percentage", 
            "# 4*fee*price*(1-price/range)/range keeps fees lower at the edges", 
            "macro fee_percent($market_fee, $price, $cumScale):", 
            "    4 * $market_fee * $price * (ONE-$price*ONE/$cumScale) / ($cumScale*ONE)", 
            "", 
            "# removes a trade from the book", 
            "macro remove_trade($trade_id, $market):", 
            "    TRADES.remove_trade($trade_id)", 
            "    MARKETS.remove_trade_from_market($market, $trade_id)", 
            "", 
            "#", 
            "# Trade [allows a user to pick up/fill orders off the book]", 
            "#", 
            "# Errors:", 
            "    # -1: oracle only branch", 
            "    # -2: bad trade hash", 
            "    # -3: trader doesn't exist / own shares in this market", 
            "    # -4: must buy at least .00000001 in", 
            "    # -5: can't pick up your own trade", 
            "    # 10: insufficient balance", 
            "    # 22: trade in same block prohibited", 
            "# max value is max money to spend to buy [including fees] filling ask orders", 
            "# max amount is max shares to sell filling bid orders", 
            "# 500k gas cost", 
            "# picks orders off the book", 
            "def trade(max_value, max_amount, trade_ids:arr, tradeGroupID):", 
            "    refund()", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        logReturn(trade_logReturn, -1)", 
            "    i = 0", 
            "    trades = 0", 
            "    while i < len(trade_ids):", 
            "        trades += trade_ids[i]", 
            "        i+=1", 
            "    tradeInfo = array(3)", 
            "    tradeInfo[0] = trades", 
            "    tradeInfo[1] = max_amount", 
            "    tradeInfo[2] = max_value", 
            "    tradeHash = sha3(tradeInfo, items=3)", 
            "    if(TRADES.checkHash(tradeHash, msg.sender)==-1):", 
            "        logReturn(trade_logReturn, -2)", 
            "    # Try to fulfill each trade passed", 
            "    t = 0", 
            "    while t < len(trade_ids):", 
            "        # Get trade", 
            "        trade = array(TRADE_FIELDS)", 
            "        trade = TRADES.get_trade(trade_ids[t], outitems=TRADE_FIELDS)", 
            "        if trade[0] != 0:", 
            "            # Get market", 
            "            type = trade[1]", 
            "            market = trade[2]", 
            "            creator = INFO.getCreator(market)", 
            "            amount = trade[3]", 
            "            price = trade[4]", 
            "            owner = trade[5]", 
            "            outcome = trade[7]", 
            "            eventID = MARKETS.getMarketEvent(market, 0)", 
            "            minValue = EVENTS.getMinValue(eventID)", 
            "            maxValue = EVENTS.getMaxValue(eventID)", 
            "            if ((maxValue != TWO or minValue != ONE) and EVENTS.getNumOutcomes(eventID) == 2):", 
            "                displayPrice = price + minValue", 
            "            else:", 
            "                displayPrice = price", 
            "            if(owner != msg.sender and owner != tx.origin):", 
            "                # Make sure the trade has been mined, obvious HFT prevention", 
            "                if block.number <= trade[6]:", 
            "                    logReturn(trade_logReturn, TRADE_SAME_BLOCK_PROHIBITED)", 
            "                branch = MARKETS.getBranchID(market)", 
            "                fee = fee_percent(MARKETS.getTradingFee(market), price, MARKETS.getCumScale(market))", 
            "                # Fill buy order", 
            "                if type == BID:", 
            "                    # Get available balance of shares", 
            "                    balance = MARKETS.getParticipantSharesPurchased(market, msg.sender, outcome)", 
            "                    if balance <= 0:", 
            "                        logReturn(trade_logReturn, INSUFFICIENT_BALANCE)", 
            "                    if max_amount > 0:", 
            "                        makerFeeRate = MARKETS.getMakerFees(market)", 
            "                        # Determine fill amount", 
            "                        fill = min(amount, min(balance, max_amount))", 
            "                        # Calculate value", 
            "                        value = (fill * price)/ONE", 
            "                        # must trade at least 0.00000001 in value", 
            "                        if value >= MINIMUM_TRADE_SIZE:", 
            "                            # Update trade amount or remove", 
            "                            if fill < amount:", 
            "                                TRADES.fill_trade(trade_ids[t], fill)", 
            "                            else:", 
            "                                remove_trade(trade_ids[t], market)", 
            "                            # Update topic popularity", 
            "                            topic = MARKETS.getTopic(market)", 
            "                            if topic:", 
            "                                TOPICS.updateTopicPopularity(branch, topic, fill)", 
            "                            # Update balances", 
            "                            MARKETS.modifyParticipantShares(market, msg.sender, outcome, -fill, 0)", 
            "                            MARKETS.modifyParticipantShares(market, owner, outcome, fill, 0)", 
            "                            # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]", 
            "                            fee = value * fee / ONE", 
            "                            branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "                            creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "                            takerFeesTotal = branchFees + creatorFees", 
            "                            CASH.addCash(msg.sender, value - takerFeesTotal)", 
            "                            # 75% to branch + .5% more to branch per maker fee 1% decrease", 
            "                            CASH.addCash(branch, branchFees)", 
            "                            # 25% to creator + .5% more to creator per 1% decrease in maker fees", 
            "                            CASH.addCash(creator, creatorFees)", 
            "                            CASH.subtractCash(market, value)", 
            "", 
            "                            # other party [maker] pays their part of the fee here too [they previously escrowed it in the market]", 
            "                            fee = fee * makerFeeRate / ONE", 
            "                            CASH.subtractCash(market, fee)", 
            "                            CASH.addCash(creator, fee/2)", 
            "                            CASH.addCash(branch, fee/2)", 
            "", 
            "                            # needed to keep track of how many fees a market has raised", 
            "                            # only count branch fees here", 
            "                            MARKETS.addFees(market, fee/2+branchFees)", 
            "                            # Update max_amount", 
            "                            max_amount -= fill", 
            "                            # Log transaction", 
            "                            log(type=log_fill_tx, market, msg.sender, owner, ASK, displayPrice, fill, trade_ids[t], outcome, block.timestamp, takerFeesTotal, fee, price, tradeHash, tradeGroupID)", 
            "                elif type == ASK:", 
            "                    balance = CASH.balance(msg.sender)", 
            "                    if balance <= 0:", 
            "                        logReturn(trade_logReturn, INSUFFICIENT_BALANCE)", 
            "                    makerFeeRate = MARKETS.getMakerFees(market)", 
            "                    takerFee = (ONEPOINTFIVE - makerFeeRate)*fee / ONE", 
            "                    total_trade_cost = amount * price / ONE * (takerFee+ONE) / ONE", 
            "                    # trade value to spend is equal to min(moneyUserOwns, moneyUserWantsToSpend, valueOfTradeThatIsUnfilledIncludingFees)", 
            "                    value_to_spend = min(total_trade_cost, min(max_value, balance))", 
            "                    # Determine fill amount", 
            "                    fill = value_to_spend*ONE / price * ONE / (takerFee+ONE)", 
            "                    trade_value_excluding_fees = fill*price/ONE", 
            "                    if(trade_value_excluding_fees >= MINIMUM_TRADE_SIZE):", 
            "                        # Update trade amount or remove filled trade", 
            "                        if fill < amount:", 
            "                            TRADES.fill_trade(trade_ids[t], fill)", 
            "                        else:", 
            "                            remove_trade(trade_ids[t], market)", 
            "                        # Update topic popularity", 
            "                        topic = MARKETS.getTopic(market)", 
            "                        if topic:", 
            "                            TOPICS.updateTopicPopularity(branch, topic, fill)", 
            "                        # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]", 
            "                        MARKETS.modifyParticipantShares(market, msg.sender, outcome, fill, 0)", 
            "", 
            "                        branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*trade_value_excluding_fees/ONE * fee / ONE", 
            "                        creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*trade_value_excluding_fees/ONE * fee / ONE", 
            "                        # Transfer cash from user to person who has ask order and pay fee to branch and market creator", 
            "                        # 75% to branch + .5% more to branch per maker fee 1% decrease", 
            "                        CASH.addCash(branch, branchFees)", 
            "                        # 25% to creator + .5% more to creator per 1% decrease in maker fees", 
            "                        CASH.addCash(creator, creatorFees)", 
            "                        takerFeesTotal = branchFees + creatorFees", 
            "                        CASH.addCash(owner, value_to_spend - takerFeesTotal)", 
            "                        CASH.subtractCash(msg.sender, value_to_spend)", 
            "", 
            "                        # other party [maker] pay their part of the fee here too", 
            "                        makerFee = trade_value_excluding_fees * makerFeeRate / ONE * fee / ONE", 
            "                        CASH.subtractCash(market, makerFee)", 
            "                        CASH.addCash(creator, makerFee/2)", 
            "                        CASH.addCash(branch, makerFee/2)", 
            "", 
            "                        # only count branch fees here", 
            "                        MARKETS.addFees(market, makerFee/2+branchFees)", 
            "                        # Update max_value", 
            "                        max_value -= value_to_spend", 
            "                        # Log transaction", 
            "                        log(type=log_fill_tx, market, msg.sender, owner, BID, displayPrice, fill, trade_ids[t], outcome, block.timestamp, takerFeesTotal, makerFee, price, tradeHash, tradeGroupID)", 
            "", 
            "        # Log price, fill amount, type and timestamp", 
            "        MARKETS.setPrice(market, outcome, displayPrice)", 
            "        # Next trade", 
            "        t += 1", 
            "    logArrayReturn([SUCCESS, max_value, max_amount])", 
            "", 
            "# Allows a user to \"short\" by buying n complete sets and selling n shares of the unwanted outcome to a bid on the book", 
            "# Example:", 
            "    #buyer gives up say 20", 
            "    #complete set cost is say 100", 
            "    #fee is say 2", 
            "    #market should lose 20 from buyer's escrowed money", 
            "    #market should gain 100 from complete set", 
            "    #person short selling should give the market 80 [complete set cost less shares sold]", 
            "    #plus fees", 
            "        #1 should go to branch", 
            "        #1 should go to creator", 
            "# Errors:", 
            "    # -1: trade doesn't exist", 
            "    # -2: invalid trade hash/commitment", 
            "    # -3: must be a bid, not an ask", 
            "    # -4: market is already resolved", 
            "    # -5: can't pickup your own trade", 
            "    # -6: can't trade on oracle only branch", 
            "    # -7: not a large enough trade", 
            "    # 10: insufficient balance", 
            "    # 22: trade in same block prohibited", 
            "def short_sell(buyer_trade_id, max_amount, tradeGroupID):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        logReturn(trade_logReturn, -6)", 
            "    # check trade hash", 
            "    tradeInfo = array(3)", 
            "    tradeInfo[0] = buyer_trade_id", 
            "    tradeInfo[1] = max_amount", 
            "    tradeInfo[2] = 0", 
            "    tradeHash = sha3(tradeInfo, items=3)", 
            "    if(TRADES.checkHash(tradeHash, msg.sender)==-1):", 
            "        logReturn(trade_logReturn, -2)", 
            "    # Get trade", 
            "    trade = array(TRADE_FIELDS)", 
            "    trade = TRADES.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)", 
            "    if trade[0] == 0:", 
            "        logReturn(trade_logReturn, -1)", 
            "    # Get market", 
            "    type = trade[1]", 
            "    if(type!=BID):", 
            "        logReturn(trade_logReturn, -3)", 
            "    market = trade[2]", 
            "    if(MARKETS.getOneWinningOutcome(market, 0)):", 
            "        logReturn(trade_logReturn, -4)", 
            "    orig_amount = trade[3]", 
            "    price = trade[4]", 
            "    owner = trade[5]", 
            "    outcome = trade[7]", 
            "    if(owner == msg.sender or owner == tx.origin):", 
            "        logReturn(trade_logReturn, -5)", 
            "    # Make sure the trade has been mined, obvious HFT prevention", 
            "    if block.number <= trade[6]:", 
            "        logReturn(trade_logReturn, TRADE_SAME_BLOCK_PROHIBITED)", 
            "", 
            "    # calculate cost", 
            "    creator = INFO.getCreator(market)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    amount = min(orig_amount, max_amount)", 
            "    if(amount < 0):", 
            "        logReturn(trade_logReturn, INSUFFICIENT_BALANCE)", 
            "    fee = amount * price / ONE * fee_percent(trading_fee, price, cumScale) / ONE", 
            "    makerFeeRate = MARKETS.getMakerFees(market)", 
            "    branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "    creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "    takerFeesTotal = branchFees + creatorFees", 
            "    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)", 
            "    if(CASH.balance(msg.sender) < cost):", 
            "        logReturn(trade_logReturn, INSUFFICIENT_BALANCE)", 
            "    if(amount*price/ONE < MINIMUM_TRADE_SIZE):", 
            "        logReturn(trade_logReturn, -7)", 
            "", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "", 
            "    # Update topic popularity", 
            "    topic = MARKETS.getTopic(market)", 
            "    if topic:", 
            "        TOPICS.updateTopicPopularity(branch, topic, amount*numOutcomes)", 
            "    i = 1", 
            "    # send shares of the event to user address, buying complete sets", 
            "    while i <= numOutcomes:", 
            "        MARKETS.modifyShares(market, i, amount)", 
            "        MARKETS.modifyParticipantShares(market, msg.sender, i, amount, 0)", 
            "        i += 1", 
            "    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):", 
            "        MARKETS.modifySharesValue(market, amount*cumScale/ONE)", 
            "        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount*cumScale/ONE)", 
            "    # send money from user acc. to market address/account", 
            "    # cost for shares", 
            "    costForShares = cost - takerFeesTotal", 
            "    if(costForShares and !CASH.sendFrom(market, costForShares, msg.sender)):", 
            "        throw()", 
            "", 
            "    # Fill buy order [short selling the outcome user doesn't want]", 
            "    # Determine fill amount", 
            "    fill = amount", 
            "    # Update trade amount or remove", 
            "    if fill < orig_amount:", 
            "        TRADES.fill_trade(buyer_trade_id, fill)", 
            "    else:", 
            "        remove_trade(buyer_trade_id, market)", 
            "    # Update topic popularity", 
            "    if topic:", 
            "        TOPICS.updateTopicPopularity(branch, topic, fill)", 
            "    # Update balances", 
            "    MARKETS.modifyParticipantShares(market, msg.sender, outcome, -fill, 0)", 
            "    MARKETS.modifyParticipantShares(market, owner, outcome, fill, 0)", 
            "    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]", 
            "    # 75% to branch + .5% more to branch per maker fee 1% decrease", 
            "    if(branchFees and !CASH.sendFrom(branch, branchFees, msg.sender)):", 
            "        throw()", 
            "    # 25% to creator + .5% more to creator per 1% decrease in maker fees", 
            "    if(creatorFees and !CASH.sendFrom(creator, creatorFees, msg.sender)):", 
            "        throw()", 
            "", 
            "    # other party [maker] pay their part of the fee here too", 
            "    fee = fee * makerFeeRate / ONE", 
            "    CASH.subtractCash(market, fee)", 
            "    CASH.addCash(creator, fee/2)", 
            "    CASH.addCash(branch, fee/2)", 
            "", 
            "    # only count branch fees here", 
            "    MARKETS.addFees(market, fee/2+branchFees)", 
            "", 
            "    max_amount -= fill", 
            "    # Log transaction", 
            "    eventID = MARKETS.getMarketEvent(market, 0)", 
            "    minValue = EVENTS.getMinValue(eventID)", 
            "    maxValue = EVENTS.getMaxValue(eventID)", 
            "    if ((maxValue != TWO or minValue != ONE) and EVENTS.getNumOutcomes(eventID) == 2):", 
            "        displayPrice = minValue + price", 
            "    else:", 
            "        displayPrice = price", 
            "    log(type=log_short_fill_tx, market, msg.sender, owner, displayPrice, fill, buyer_trade_id, outcome, block.timestamp, takerFeesTotal, fee, numOutcomes, price, tradeHash, tradeGroupID)", 
            "    MARKETS.setPrice(market, outcome, displayPrice)", 
            "    logArrayReturn([SUCCESS, max_amount, fill, price])"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "buyer_trade_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "short_sell(int256,int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "max_value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_ids", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "trade(int256,int256,int256[],int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "owner", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "takerFee", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "makerFee", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "onChainPrice", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeHash", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "log_fill_tx(int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "owner", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "takerFee", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "makerFee", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "onChainPrice", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeHash", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeGroupID", 
                        "type": "int256"
                    }
                ], 
                "name": "log_short_fill_tx(int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": false, 
                        "name": "returnArray", 
                        "type": "int256[]"
                    }
                ], 
                "name": "trade_logArrayReturn(int256[])", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": false, 
                        "name": "returnValue", 
                        "type": "int256"
                    }
                ], 
                "name": "trade_logReturn(int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern trade: [short_sell:[int256,int256,int256]:_, test_callstack:[]:int256, trade:[int256,int256,int256[],int256]:_]"
    }, 
    "trades": {
        "address": "0xd70c6e1f3857d23bd96c3e4d2ec346fa7c3931f3", 
        "code": [
            "inset('refund.se')", 
            "", 
            "### Storage of all data associated with trades", 
            "", 
            "# reporterID is index", 
            "data tradeCommits[](hash, block)", 
            "# tradeID is index", 
            "data trades[](id, type, market, amount, price, owner, block, outcome)", 
            "# indices are marketID and outcomeID", 
            "data bestTrade[][](bid, ask)", 
            "", 
            "def makeTradeHash(max_value, max_amount, trade_ids: arr):", 
            "    refund()", 
            "    i = 0", 
            "    trades = 0", 
            "    while i < len(trade_ids):", 
            "        trades += trade_ids[i]", 
            "        i+=1", 
            "    tradeInfo = array(3)", 
            "    tradeInfo[0] = trades", 
            "    tradeInfo[1] = max_amount", 
            "    tradeInfo[2] = max_value", 
            "    tradeHash = sha3(tradeInfo, items=3)", 
            "    return(tradeHash)", 
            "", 
            "def commitTrade(hash):", 
            "    refund()", 
            "    self.tradeCommits[msg.sender].hash = hash", 
            "    self.tradeCommits[msg.sender].block = block.number", 
            "    return(1)", 
            "", 
            "def zeroHash():", 
            "    refund()", 
            "    self.tradeCommits[msg.sender].hash = 0", 
            "    return(1)", 
            "", 
            "def checkHash(tradeHash, sender):", 
            "    refund()", 
            "    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):", 
            "        return(-1)", 
            "    else:", 
            "        return(1)", 
            "", 
            "def getID(tradeID):", 
            "    refund()", 
            "    return(self.trades[tradeID].id)", 
            "", 
            "def getBestBidID(market, outcome):", 
            "    return(self.bestTrade[market][outcome].bid)", 
            "", 
            "def getBestAskID(market, outcome):", 
            "    return(self.bestTrade[market][outcome].ask)", 
            "", 
            "def saveTrade(trade_id, type, market, amount, price, sender, outcome):", 
            "    refund()", 
            "    self.trades[trade_id].id = trade_id", 
            "    self.trades[trade_id].type = type", 
            "    self.trades[trade_id].market = market", 
            "    self.trades[trade_id].amount = amount", 
            "    self.trades[trade_id].price = price", 
            "    self.trades[trade_id].owner = sender", 
            "    self.trades[trade_id].block = block.number", 
            "    self.trades[trade_id].outcome = outcome", 
            "", 
            "    # Update best bid and ask trade IDs:", 
            "    #  - if this outcome's best trade is set, but this trade price is better,", 
            "    #    then this trade ID is the new best trade", 
            "    #  - if this outcome's best trade is unset, then this trade ID is the new", 
            "    #    best trade", 
            "    if type == 1:", 
            "        bestBidID = self.bestTrade[market][outcome].bid", 
            "        if bestBidID == 0 or price > self.trades[bestBidID].price:", 
            "            self.bestTrade[market][outcome].bid = trade_id", 
            "    else:", 
            "        bestAskID = self.bestTrade[market][outcome].ask", 
            "        if bestAskID == 0 or price < self.trades[bestAskID].price:", 
            "            self.bestTrade[market][outcome].ask = trade_id", 
            "", 
            "    return(1)", 
            "", 
            "def getTradeOwner(id):", 
            "    refund()", 
            "    return(self.trades[id].owner)", 
            "", 
            "def get_trade(id):", 
            "    refund()", 
            "    trade = array(8)", 
            "    trade[0] = self.trades[id].id", 
            "    trade[1] = self.trades[id].type", 
            "    trade[2] = self.trades[id].market", 
            "    trade[3] = self.trades[id].amount", 
            "    trade[4] = self.trades[id].price", 
            "    trade[5] = self.trades[id].owner", 
            "    trade[6] = self.trades[id].block", 
            "    trade[7] = self.trades[id].outcome", 
            "    if trade:", 
            "        return(trade:arr)", 
            "    return([0]:arr)", 
            "", 
            "def get_trade_block(id):", 
            "    refund()", 
            "    return(self.trades[id].block)", 
            "", 
            "def get_amount(id):", 
            "    refund()", 
            "    return(self.trades[id].amount)", 
            "", 
            "def get_price(id):", 
            "    refund()", 
            "    return(self.trades[id].price)", 
            "", 
            "def update_trade(id, price):", 
            "    refund()", 
            "    self.trades[id].price = price", 
            "    self.trades[id].block = block.number", 
            "", 
            "def remove_trade(id):", 
            "    refund()", 
            "    market = self.trades[id].market", 
            "    outcome = self.trades[id].outcome", 
            "    if self.bestTrade[market][outcome].bid == id:", 
            "        self.bestTrade[market][outcome].bid = 0", 
            "    elif self.bestTrade[market][outcome].ask == id:", 
            "        self.bestTrade[market][outcome].ask = 0", 
            "    self.trades[id].id = 0", 
            "    self.trades[id].type = 0", 
            "    self.trades[id].market = 0", 
            "    self.trades[id].amount = 0", 
            "    self.trades[id].price = 0", 
            "    self.trades[id].owner = 0", 
            "    self.trades[id].block = 0", 
            "    self.trades[id].outcome = 0", 
            "    return(1)", 
            "", 
            "def fill_trade(id, fill):", 
            "    refund()", 
            "    self.trades[id].amount -= fill", 
            "    return(1)", 
            "", 
            "def getSender():", 
            "    return(msg.sender)"
        ], 
        "fullsig": [
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "tradeHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "checkHash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "hash", 
                        "type": "int256"
                    }
                ], 
                "name": "commitTrade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fill", 
                        "type": "int256"
                    }
                ], 
                "name": "fill_trade(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getBestAskID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getBestBidID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "tradeID", 
                        "type": "int256"
                    }
                ], 
                "name": "getID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "getSender()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradeOwner(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_amount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_price(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_trade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_trade_block(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "max_value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_ids", 
                        "type": "int256[]"
                    }
                ], 
                "name": "makeTradeHash(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "remove_trade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "saveTrade(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "test_callstack()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }
                ], 
                "name": "update_trade(int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "constant": false, 
                "inputs": [], 
                "name": "zeroHash()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getBestAskID:[int256,int256]:int256, getBestBidID:[int256,int256]:int256, getID:[int256]:int256, getSender:[]:int256, getTradeOwner:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], get_trade_block:[int256]:int256, makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, test_callstack:[]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]"
    }
}